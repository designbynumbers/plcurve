/*
 *  Routines to create, destroy, read and write plCurves (and strands)
 *
 *  $Id: plCurve.c,v 1.90 2007-09-21 21:08:43 cantarel Exp $
 *
 */

/* Copyright 2004 The University of Georgia. */

/* This file is part of plCurve.

plCurve is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

plCurve is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with plCurve; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/

#include <config.h>
#include <plCurve.h>
#include <matrix.h>

#ifdef HAVE_STDLIB_H
  #include <stdlib.h>
#endif
#ifdef HAVE_MATH_H
  #include <math.h>
#endif
#ifdef HAVE_MALLOC_H
  #include <malloc.h>
#endif
#ifdef HAVE_STDARG_H
  #include <stdarg.h>
#endif
#ifdef HAVE_CTYPE_H
  #include <ctype.h>
#endif
#ifdef HAVE_STRING_H
  #include <string.h>
#endif
#ifdef HAVE_ASSERT_H
  #include <assert.h>
#endif
#ifdef HAVE_FLOAT_H
  #include <float.h>
#endif
#ifdef HAVE_TIME_H
  #include <time.h>
#endif
#ifdef HAVE_GSL_GSL_COMBINATION_H
  #include <gsl/gsl_combination.h>

float *plc_dihedral_angles(const plCurve * const L, unsigned int *ndihedrals)

/* Return a buffer of (4 2) (n 4) dihedral angles given by taking all 4-tuples of vertices 
   generated by gsl_combination.h and then taking each of the (4 2) possible pairs as the 
   diagonal of the resulting quadrilateral. If ndihedrals is non-negative, will limit
   to this number of dihedrals.

   Since memory can very easily be an issue here, we return results in SINGLE precision.
   If we can't compute an angle, we return it in place as -1.0 to indicate that this is
   bad data. 
*/

{
  int n = L->cp[0].nv;

  unsigned int max_ndihedrals = (n*(n-1)*(n-2)*(n-3)*(n-4))/4;

  if (*ndihedrals == 0) { 

    *ndihedrals = max_ndihedrals; 

  } else {

    *ndihedrals = *ndihedrals > max_ndihedrals ? max_ndihedrals : *ndihedrals;

  }

  float *angles;
  angles = calloc(*ndihedrals,sizeof(float));
  
  if (angles == NULL) { 

    return NULL;

  }

  gsl_combination *combo;
  combo = gsl_combination_calloc(n,4);

  if (combo == NULL) {

    free(angles);
    return NULL;

  }

  unsigned int i;

  for(i=0;i<*ndihedrals;gsl_combination_next(combo)) { 

    bool ok1,ok2,ok3;
    plc_vector a,b,c,d;

    a = L->cp[0].vt[gsl_combination_get(combo,0)];
    b = L->cp[0].vt[gsl_combination_get(combo,1)];
    c = L->cp[0].vt[gsl_combination_get(combo,2)];
    d = L->cp[0].vt[gsl_combination_get(combo,3)];

    angles[i] = plc_angle(plc_normal(a,b,d,&ok1),plc_normal(b,c,d,&ok2),&ok3);
    if (!ok1 || !ok2 || !ok3) { angles[i] = -1.0; }
    i++;
    
    angles[i] = plc_angle(plc_normal(a,b,c,&ok1),plc_normal(c,d,a,&ok2),&ok3);
    if (!ok1 || !ok2 || !ok3) { angles[i] = -1.0; }
    i++;
    
  }

  gsl_combination_free(combo);
  return angles;

}

#else
double *plc_dihedral_angles(const plCurve * const L)
{
  return NULL;
}
#endif
