
/*

   test_tangle_slide_ops_auto.c : This code is auto-generated
   by 'assemble_tangleslideops.py' and shouldn't be edited
   by hand. It contains tests for pd_tangle_slide.


*/

#ifdef HAVE_CONFIG_H
  #include"config.h"
#endif

#ifdef HAVE_STDIO_H
   #include<stdio.h>
#endif

#ifdef HAVE_ASSERT_H
   #include<assert.h>
#endif

#ifdef HAVE_STRING_H
   #include<string.h>
#endif

#ifdef HAVE_STDINT_H
   #include<stdint.h>
#endif

#ifdef HAVE_STDLIB_H
   #include<stdlib.h>
#endif

#ifdef HAVE_STDBOOL_H
   #include<stdbool.h>
#endif

#include<plcTopology.h>
#include<pd_multidx.h>
#include<pd_perm.h>

int PD_VERBOSE=15;

/* We need a utility function to do the tests... */

bool compare_list_of_pds(pd_idx_t nA, pd_code_t **A,
                         pd_idx_t nB, pd_code_t **B)

/* Figure out whether there's a match between the list of
   pds in A and the list in B. Since we expect the lists
   to be kind of small, we're just brute-forcing
   this (of course, there are many cleverer ways to do it). */

{{
  printf("\tchecking that lists of pd codes are same size...");
  
  if (nA == nB) {{ 

    printf("pass (%d child pd codes)\n",nA);

  }} else {{ 

    printf("FAIL. (lists are size %d != %d)\n",nA,nB);
    return false;

  }}

  pd_perm_t *perm;
  perm = pd_new_perm((void *)(&nA));
  bool all_iso = true;

  printf("\tchecking up to %u perms for diagram isotopy match between lists...",
	 pd_nperms((void *)(perm)));
  
  do {{  /* Check the current permutation. */

    pd_idx_t i; 

    for(i=0,all_iso = true;i < nA && all_iso;i++) {{

      if (!pd_diagram_isotopic(A[i],B[perm->map[i]])) {{ all_iso = false; }}

    }}
    
    pd_increment_perm((void *)(perm));

  }} while (!all_iso && !pd_perm_is_e(perm));

  if (all_iso) {{ 

    /* We need a trick here-- we can't DECREMENT the perm
       (though we'd like to) in order to report the
       permutation that we actually used. 
       But we can increment it n-1 times... */

    pd_idx_t np = pd_nperms((void *)(perm));
    pd_idx_t i;
    for(i=0;i<np-1;i++) {{ pd_increment_perm((void *)(perm)); }}

    pd_printf("pass\n\t(%PERM matches pd codes "
              "in list A with list B)\n",NULL,perm);
    
  }} else {{

    printf("FAIL (could not find a match between codes in list)\n");
    return false;

  }}

  pd_free_perm((void **)(&perm));

  return true;

}}                        
/* tangle slide operations a assembled c code */

pd_code_t *pd_create_tangle_slide_operation_testa_before_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(4);
assert(pd != NULL);
pd->ncross = 4;
pd->nedges = 8;
pd->ncomps = 1;
pd->nfaces = 6;
sprintf(pd->hash,"%s","BAgGAwMDAwICAQgAAAAAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 7;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 5;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 6;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 5;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 4;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 6;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 7;
pd->cross[3].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 2;
pd->edge[4].headpos = 3;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 1;
pd->edge[5].headpos = 1;
pd->edge[5].tail = 2;
pd->edge[5].tailpos = 1;

pd->edge[6].head = 3;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 3;

pd->edge[7].head = 0;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 3;
pd->edge[7].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 8;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;


/* Face data */

pd->face[0].nedges = 3;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 2;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 5;
pd->face[0].or[2] = 1;

pd->face[1].nedges = 3;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 6;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 3;
pd->face[1].or[2] = 0;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 4;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 6;
pd->face[2].or[2] = 0;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 7;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 4;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 1;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 5;
pd->face[4].or[1] = 0;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 7;
pd->face[5].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}

pd_code_t *pd_create_tangle_slide_operation_testa_after_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(4);
assert(pd != NULL);
pd->ncross = 4;
pd->nedges = 8;
pd->ncomps = 1;
pd->nfaces = 6;
sprintf(pd->hash,"%s","BAgGBQMDAgIBAQgAAAAAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 1;
pd->cross[0].edge[3] = 4;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 7;
pd->cross[1].edge[2] = 7;
pd->cross[1].edge[3] = 6;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 5;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 4;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 5;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 6;
pd->cross[3].sign = 0;


/* Edge data */

pd->edge[0].head = 0;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 1;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 0;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 0;
pd->edge[3].headpos = 1;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 2;
pd->edge[4].headpos = 3;
pd->edge[4].tail = 0;
pd->edge[4].tailpos = 3;

pd->edge[5].head = 3;
pd->edge[5].headpos = 1;
pd->edge[5].tail = 2;
pd->edge[5].tailpos = 1;

pd->edge[6].head = 1;
pd->edge[6].headpos = 3;
pd->edge[6].tail = 3;
pd->edge[6].tailpos = 3;

pd->edge[7].head = 1;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 1;
pd->edge[7].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 8;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;


/* Face data */

pd->face[0].nedges = 5;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 4;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 2;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 7;
pd->face[0].or[4] = 0;

pd->face[1].nedges = 3;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 6;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 3;
pd->face[1].or[2] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 3;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 5;
pd->face[2].or[2] = 0;

pd->face[3].nedges = 2;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 1;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 4;
pd->face[3].or[1] = 0;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 5;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 1;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 7;
pd->face[5].or[0] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tangle_slide_ops_testa() {

  /*                                                           */
/*                                                           */
/*                         +---------e6----------+           */
/*                         o                     |           */
/*              (2)        o <-overstrand        |           */
/*                         o                     |           */
/*   T-> +------------+    v                     |           */
/*       |            |    |c3                   |           */
/*       |    +-------|------------+             |           */
/*       |    |       |    o       |             |           */
/*       |   e4       |    e7     e3             |           */
/*       |    |   (3) |    v  (5)  |             |           */
/*       |  c2|       |    o       |             |           */
/*    +--|----|--->---|-e2------>--+             |           */
/*    |  |    v       |    oc0                   |           */
/*   e1  +------------+    v           (1)       |           */
/*    | (4)  e5    (0)     o                     |           */
/*    +---<---------e0--ooo+                     |           */
/*          c1|                                  |           */
/*            +----->-------e6-------------------+           */
					 
pd_idx_t nedges = 4;			 
pd_idx_t tangle_faces[4] = {0,3,2,4};	 
pd_idx_t tangle_edges[4] = {2,4,1,5};  	 
				       	 
pd_idx_t noverstrand_edges = 3;	       	 
pd_idx_t overstrand_edges[3] = {6,7,0};	 
pd_idx_t border_faces[3] = {2,3,0};    	 
				       	 
/*                                                       .   */
/*                                                           */
/*     +-------2--------+             +---------+            */
/*     |                |             |         |            */
/*     |      (4)       v      (0)    7   (5)   |            */
/*     |                |             |         |            */
/*     2                |c3-          |	c1+     |            */
/*     |      +---5--------->---6-----|----7----+            */
/*     |      ^   (2)   3     (1)     |                      */
/*     |   c2+|         |c0+          v	                     */
/*     +--<---|----1-<---------0--<---+	                     */
/*            |         |                                    */
/*            ^         v                                    */
/*            4   (3)   |                                    */
/*            |         4                                    */
/*            |         |                                    */
/*            +---------+                                    */
/*                                                           */
/*                                                           */
/*                                                           */


  printf("--------------------------------------------------\n"
    	 "pdint check tangle slide ops test a\n"
         "--------------------------------------------------\n");

  printf("creating 'before' pd...");
  pd_code_t *pd = pd_create_tangle_slide_operation_testa_before_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("parsing tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("parsing overstrand_edges and border_faces...");
  printf("%d overstrand edges\n",noverstrand_edges);

  printf("running pd_tangle_slide...");

  pd_code_t **children;
  pd_idx_t nchildren;

  pd_tangle_slide(pd,t,
                  noverstrand_edges,overstrand_edges,border_faces,
                  &nchildren,&children);

  printf("pass (didn't crash, returned %d children)\n",nchildren);
  
  printf("checking children for pd_ok...\n");
  
  for(i=0;i<nchildren;i++) {

     if (!pd_ok(children[i])) {

        pd_printf("child %d fails pd_ok. \n %PD",children[i],i);
        return false;

     } else {

        printf("\t%d crossing child pd #%d is pd_ok...pass\n",
               children[i]->ncross,i);

     }

   }
  
   pd_idx_t nxchildren = 1;
   pd_code_t *xchildren[1];
   xchildren[0] = pd_create_tangle_slide_operation_testa_after_0();


   printf("checking %d expected children for pd_ok...\n",nxchildren);

   for(i=0;i<nxchildren;i++) {

    if (!pd_ok(xchildren[i])) {

       pd_printf("expected child %d failed pd_ok:\n %PD",xchildren[i],i);
       return false;

    } else {

       printf("\t%d crossing expected child pd #%d is pd_ok...pass\n",
              xchildren[i]->ncross,i);

    }

   }

   printf("comparing list of xchildren against actual children...\n");

   if (!compare_list_of_pds(nchildren,children,nxchildren,xchildren)) {

       printf("FAIL. Couldn't match expected and actual children\n"
              "after tangle_slide\n");
       return false;

   } else {

       printf("comparing list of xchildren against actual children...pass\n");

    }

  printf("housecleaning...\n");

  printf("\tfreeing parent pd and tangle...");
  pd_code_free(&pd);
  pd_tangle_free(&t);
  printf("done\n");

  printf("\tfreeing list of children and children buffer...");
  for(i=0;i<nchildren;i++) {
     pd_code_free(&(children[i]));
  }
  free(children);
  printf("done\n");

  printf("\tfreeing list of xchildren...");
  for(i=0;i<nxchildren;i++) {
     pd_code_free(&(xchildren[i]));
  }
  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint check tangle slide ops testa : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle slide operations b assembled c code */

pd_code_t *pd_create_tangle_slide_operation_testb_before_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(7);
assert(pd != NULL);
pd->ncross = 7;
pd->nedges = 14;
pd->ncomps = 3;
pd->nfaces = 9;
sprintf(pd->hash,"%s","Bw4JBwQEAwICAgICAwgEAgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 8;
pd->cross[0].edge[2] = 1;
pd->cross[0].edge[3] = 9;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 11;
pd->cross[1].edge[2] = 7;
pd->cross[1].edge[3] = 8;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 4;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 5;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 6;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 5;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 6;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 7;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 9;
pd->cross[5].edge[1] = 13;
pd->cross[5].edge[2] = 10;
pd->cross[5].edge[3] = 12;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 10;
pd->cross[6].edge[1] = 13;
pd->cross[6].edge[2] = 11;
pd->cross[6].edge[3] = 12;
pd->cross[6].sign = 1;


/* Edge data */

pd->edge[0].head = 0;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 1;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 0;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 2;
pd->edge[4].headpos = 1;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 3;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 2;
pd->edge[5].tailpos = 3;

pd->edge[6].head = 4;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 3;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 1;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 4;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 0;
pd->edge[8].headpos = 1;
pd->edge[8].tail = 1;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 5;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 0;
pd->edge[9].tailpos = 3;

pd->edge[10].head = 6;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 5;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 1;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 6;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 5;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 6;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 6;
pd->edge[13].headpos = 1;
pd->edge[13].tail = 5;
pd->edge[13].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 8;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 8;
pd->comp[1].edge[1] = 9;
pd->comp[1].edge[2] = 10;
pd->comp[1].edge[3] = 11;

pd->comp[2].nedges = 2;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 12;
pd->comp[2].edge[1] = 13;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 5;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 3;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 7;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 11;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 13;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 9;
pd->face[0].or[6] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 9;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 12;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 11;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 8;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 7;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 4;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 4;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 6;
pd->face[3].or[2] = 0;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 0;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 2;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 5;
pd->face[5].or[1] = 0;

pd->face[6].nedges = 2;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 6;
pd->face[6].or[1] = 1;

pd->face[7].nedges = 2;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 10;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 12;
pd->face[7].or[1] = 1;

pd->face[8].nedges = 2;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 10;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 13;
pd->face[8].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}

pd_code_t *pd_create_tangle_slide_operation_testb_after_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(7);
assert(pd != NULL);
pd->ncross = 7;
pd->nedges = 14;
pd->ncomps = 2;
pd->nfaces = 9;
sprintf(pd->hash,"%s","Bw4JBwQEAwICAgICAgoEAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 11;
pd->cross[0].edge[2] = 9;
pd->cross[0].edge[3] = 12;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 12;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 13;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 10;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 13;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 5;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 6;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 7;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 6;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 4;
pd->cross[5].edge[1] = 7;
pd->cross[5].edge[2] = 5;
pd->cross[5].edge[3] = 8;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 8;
pd->cross[6].edge[1] = 10;
pd->cross[6].edge[2] = 9;
pd->cross[6].edge[3] = 11;
pd->cross[6].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 5;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 3;
pd->edge[5].headpos = 1;
pd->edge[5].tail = 5;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 4;
pd->edge[6].headpos = 3;
pd->edge[6].tail = 3;
pd->edge[6].tailpos = 3;

pd->edge[7].head = 5;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 4;
pd->edge[7].tailpos = 1;

pd->edge[8].head = 6;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 5;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 0;
pd->edge[9].headpos = 2;
pd->edge[9].tail = 6;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 6;
pd->edge[10].headpos = 1;
pd->edge[10].tail = 2;
pd->edge[10].tailpos = 1;

pd->edge[11].head = 0;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 6;
pd->edge[11].tailpos = 3;

pd->edge[12].head = 1;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 0;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 2;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 1;
pd->edge[13].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 10;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 10;
pd->comp[1].edge[1] = 11;
pd->comp[1].edge[2] = 12;
pd->comp[1].edge[3] = 13;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 13;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 2;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 4;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 8;
pd->face[0].or[5] = 1;

pd->face[0].edge[6] = 11;
pd->face[0].or[6] = 1;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 12;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 10;
pd->face[1].or[3] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 2;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 10;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 8;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 5;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 3;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 5;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].or[2] = 0;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 0;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 12;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 1;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 13;
pd->face[5].or[1] = 0;

pd->face[6].nedges = 2;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 6;
pd->face[6].or[1] = 0;

pd->face[7].nedges = 2;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 4;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 1;

pd->face[8].nedges = 2;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 9;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 11;
pd->face[8].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}

pd_code_t *pd_create_tangle_slide_operation_testb_after_1() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(2);
assert(pd != NULL);
pd->ncross = 0;
pd->nedges = 1;
pd->ncomps = 1;
pd->nfaces = 2;
sprintf(pd->hash,"%s","AAECAQEBAQAAAAAAAAAAAAAAAAAAAAA");

/* Crossing data. */


/* Edge data */

pd->edge[0].head = -1;
pd->edge[0].headpos = 4;
pd->edge[0].tail = -1;
pd->edge[0].tailpos = 4;


/* Component Data */

pd->comp[0].nedges = 1;
pd->comp[0].tag = 'C';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;


/* Face data */

pd->face[0].nedges = 1;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[1].nedges = 1;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tangle_slide_ops_testb() {

  /*                                                          */
/*                                        (1)               */
/*                      /->--0-A--\                         */
/*                      |c1+ (4)  |c0-                      */
/*         /000-11-0->-------8-->----0000-B-000\            */
/*         0            ^         v            |            */
/*         0   (0)      7   (2)   1     (0)    B            */
/*         0   T->+-------------------+        |            */
/*         0      |     |c4-      vc2-|        0            */
/*         0   /--|->3--|----4->------|-5-\    0            */
/*         0   |  |     |   (3)   |   |   |    |            */
/*         0   ^  |     \--6--\   2   |   v    V            */
/*         0   3  |(6)        ^   v  (5)  5    |            */
/*         0   |  |      /<-A-|---/   |   |    0            */
/*         |   A  |      | c3+|       |   A    0            */
/*         11  \--|---3--/    \--<-5--|---/    |            */
/*         |      |       (0)         |        9            */
/*         0   /--|---C------13-------|---\    |            */
/*         ^   |  |                   |   |    0            */
/*         0   v  +-------------------+   ^    v            */
/*         0   |          (8)             |    0            */
/*         \000000-B-000000-10-000000-<-0000000/            */
/*          c6-|           (7)            |c5-              */
/*             \--------C----12---->------/                 */
/*                                                          */
/*    (1)                                                   */
       	       	  
pd_idx_t nedges = 8;
pd_idx_t tangle_faces[8] = {2,0,6,0 ,8, 0,5,0};
pd_idx_t tangle_edges[8] = {7,3,3,13,13,5,5,1};

pd_idx_t noverstrand_edges = 3;
pd_idx_t overstrand_edges[3] = {9,10,11};
pd_idx_t border_faces[3] = {0,8,0};

/*                                                          */
/*                                                          */
/*                     /-A--0-->--\                         */
/*     	       	   c0+ |       	  | c1-                     */
/*            /--11--------12>--B--------\                  */
/*            B        9          1      B                  */
/*            ^    c7- |          |      v                  */
/*            \--11--------10<--B-----13-/                  */
/*                     ^          2 c2+                     */
/*                     8          v                         */
/*            /---4->--|--->-5--A----->6---\                */
/*            |    c5- |          | c3-    |                */
/*            |        \--7-<--\  3        v                */
/*            ^                |  v        |                */
/*            |            /---|--/        6                */
/*            4            |   | c4+       |                */
/*            |            v   |           A                */
/*            A            4   \--<--6-----/                */
/*            |            |                                */
/*            \-----A------/                                */
/*                                                          */
/*                                                          */
/*                                                          */
/*                                                          */
/*                                                          */
/*                                                          */
/*                                                          */


  printf("--------------------------------------------------\n"
    	 "pdint check tangle slide ops test b\n"
         "--------------------------------------------------\n");

  printf("creating 'before' pd...");
  pd_code_t *pd = pd_create_tangle_slide_operation_testb_before_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("parsing tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("parsing overstrand_edges and border_faces...");
  printf("%d overstrand edges\n",noverstrand_edges);

  printf("running pd_tangle_slide...");

  pd_code_t **children;
  pd_idx_t nchildren;

  pd_tangle_slide(pd,t,
                  noverstrand_edges,overstrand_edges,border_faces,
                  &nchildren,&children);

  printf("pass (didn't crash, returned %d children)\n",nchildren);
  
  printf("checking children for pd_ok...\n");
  
  for(i=0;i<nchildren;i++) {

     if (!pd_ok(children[i])) {

        pd_printf("child %d fails pd_ok. \n %PD",children[i],i);
        return false;

     } else {

        printf("\t%d crossing child pd #%d is pd_ok...pass\n",
               children[i]->ncross,i);

     }

   }
  
   pd_idx_t nxchildren = 2;
   pd_code_t *xchildren[2];
   xchildren[0] = pd_create_tangle_slide_operation_testb_after_0();
   xchildren[1] = pd_create_tangle_slide_operation_testb_after_1();


   printf("checking %d expected children for pd_ok...\n",nxchildren);

   for(i=0;i<nxchildren;i++) {

    if (!pd_ok(xchildren[i])) {

       pd_printf("expected child %d failed pd_ok:\n %PD",xchildren[i],i);
       return false;

    } else {

       printf("\t%d crossing expected child pd #%d is pd_ok...pass\n",
              xchildren[i]->ncross,i);

    }

   }

   printf("comparing list of xchildren against actual children...\n");

   if (!compare_list_of_pds(nchildren,children,nxchildren,xchildren)) {

       printf("FAIL. Couldn't match expected and actual children\n"
              "after tangle_slide\n");
       return false;

   } else {

       printf("comparing list of xchildren against actual children...pass\n");

    }

  printf("housecleaning...\n");

  printf("\tfreeing parent pd and tangle...");
  pd_code_free(&pd);
  pd_tangle_free(&t);
  printf("done\n");

  printf("\tfreeing list of children and children buffer...");
  for(i=0;i<nchildren;i++) {
     pd_code_free(&(children[i]));
  }
  free(children);
  printf("done\n");

  printf("\tfreeing list of xchildren...");
  for(i=0;i<nxchildren;i++) {
     pd_code_free(&(xchildren[i]));
  }
  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint check tangle slide ops testb : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}


int main() {

  printf("test_tangle_slide_operation (%s)\n",PACKAGE_STRING);
  printf("--------------------------------------------------------\n"
	 "Unit tests for pd_tangle_slide. \n"
	 "========================================================\n");

  if (pdint_check_tangle_slide_ops_testa()&&pdint_check_tangle_slide_ops_testb()) {

    printf("=======================================================\n");
    printf("test_tangle_slide_operation:  PASS.\n");
    exit(0);

  } else {

    printf("=====================================================\n");
    printf("test_tangle_slide_operation:  FAIL.\n");
    exit(1);

  }

  return 0;

}