
/*

   test_tangle_slide_input_auto.c : This code is auto-generated by 'assemble_tangleregentest.py' and shouldn't be edited by hand. It contains tests for the gatekeeper code in pd_tangle_slide.


*/

#ifdef HAVE_CONFIG_H
  #include"config.h"
#endif

#ifdef HAVE_STDIO_H
   #include<stdio.h>
#endif

#ifdef HAVE_ASSERT_H
   #include<assert.h>
#endif

#ifdef HAVE_STRING_H
   #include<string.h>
#endif

#ifdef HAVE_STDINT_H
   #include<stdint.h>
#endif

#ifdef HAVE_STDLIB_H
   #include<stdlib.h>
#endif

#ifdef HAVE_STDBOOL_H
   #include<stdbool.h>
#endif

#include<plcTopology.h>

int PD_VERBOSE=15;

/* We need to include a prototype for the function we're testing, because
   it's not exposed in the header files. */

bool pdint_check_tslide_data_ok_and_find_te(pd_code_t *pd,pd_tangle_t *t,
					    pd_idx_t n,
					    pd_idx_t *overstrand_edges, 
					    pd_idx_t *border_faces,
					    pd_idx_t **tangle_slide_edges,
					    pd_idx_t **complementary_edges,
					    pd_boundary_or_t **complementary_or,
					    bool *overstrand_goes_OVER,
					    pd_or_t *overstrand_orientation);
/* tangle interior test W assembled c code */

pd_code_t *pd_create_tangle_slide_input_testW_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(10);
assert(pd != NULL);
pd->ncross = 10;
pd->nedges = 20;
pd->ncomps = 2;
pd->nfaces = 12;
sprintf(pd->hash,"%s","ChQMBQUEBAMDAwMDAwICAg4GAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 8;
pd->cross[0].edge[2] = 1;
pd->cross[0].edge[3] = 7;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 9;
pd->cross[1].edge[2] = 13;
pd->cross[1].edge[3] = 8;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 16;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 17;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 11;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 15;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 14;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 4;
pd->cross[5].edge[1] = 9;
pd->cross[5].edge[2] = 5;
pd->cross[5].edge[3] = 10;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 5;
pd->cross[6].edge[1] = 18;
pd->cross[6].edge[2] = 6;
pd->cross[6].edge[3] = 19;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 6;
pd->cross[7].edge[1] = 18;
pd->cross[7].edge[2] = 7;
pd->cross[7].edge[3] = 17;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 10;
pd->cross[8].edge[1] = 19;
pd->cross[8].edge[2] = 11;
pd->cross[8].edge[3] = 14;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 12;
pd->cross[9].edge[1] = 16;
pd->cross[9].edge[2] = 13;
pd->cross[9].edge[3] = 15;
pd->cross[9].sign = 1;


/* Edge data */

pd->edge[0].head = 0;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 1;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 0;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 5;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 6;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 5;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 7;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 6;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 0;
pd->edge[7].headpos = 3;
pd->edge[7].tail = 7;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 1;
pd->edge[8].headpos = 3;
pd->edge[8].tail = 0;
pd->edge[8].tailpos = 1;

pd->edge[9].head = 5;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 1;
pd->edge[9].tailpos = 1;

pd->edge[10].head = 8;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 5;
pd->edge[10].tailpos = 3;

pd->edge[11].head = 3;
pd->edge[11].headpos = 3;
pd->edge[11].tail = 8;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 9;
pd->edge[12].headpos = 0;
pd->edge[12].tail = 3;
pd->edge[12].tailpos = 1;

pd->edge[13].head = 1;
pd->edge[13].headpos = 2;
pd->edge[13].tail = 9;
pd->edge[13].tailpos = 2;

pd->edge[14].head = 4;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 8;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 9;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 4;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 2;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 9;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 7;
pd->edge[17].headpos = 3;
pd->edge[17].tail = 2;
pd->edge[17].tailpos = 3;

pd->edge[18].head = 6;
pd->edge[18].headpos = 1;
pd->edge[18].tail = 7;
pd->edge[18].tailpos = 1;

pd->edge[19].head = 8;
pd->edge[19].headpos = 1;
pd->edge[19].tail = 6;
pd->edge[19].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 14;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;

pd->comp[1].nedges = 6;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 14;
pd->comp[1].edge[1] = 15;
pd->comp[1].edge[2] = 16;
pd->comp[1].edge[3] = 17;
pd->comp[1].edge[4] = 18;
pd->comp[1].edge[5] = 19;


/* Face data */

pd->face[0].nedges = 5;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 7;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 18;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 5;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 9;
pd->face[0].or[4] = 0;

pd->face[1].nedges = 5;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 2;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 11;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 19;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 6;
pd->face[1].or[3] = 1;

pd->face[1].edge[4] = 17;
pd->face[1].or[4] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 8;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 13;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 16;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 4;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 15;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 13;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 9;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 1;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 17;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 7;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 2;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 16;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 0;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 12;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 15;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 3;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 14;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 11;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 4;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 10;
pd->face[8].or[1] = 1;

pd->face[8].edge[2] = 14;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 3;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 5;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 19;
pd->face[9].or[1] = 1;

pd->face[9].edge[2] = 10;
pd->face[9].or[2] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 0;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 8;
pd->face[10].or[1] = 0;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 6;
pd->face[11].or[0] = 0;

pd->face[11].edge[1] = 18;
pd->face[11].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testW() {

  /*                                                         */
/*                                                         */
/*                                                         */
/*                                                         */
/*             /-----0-->--\                               */
/*             ^           |                               */
/*             |c1-        |c0+                            */
/*     /--9--------<-8----------<----7-----------\         */
/*     |       13          |                     ^         */
/*     |       |c9+        1                     |c7+      */
/*     |  /----------16->-------------17--->----------\    */
/*     v  |    ^    (5)    v c2-                 |    |    */
/*     |  ^  +-------------+------+<-tangle      |    |    */
/*     |  |  | |   /--<-2--/      |              |    |    */
/*     |  |  | 12  |              |              |    |    */
/*     |  |  | |   |c3+           |              |    |    */
/*     9  |  | \-------\          | (1)          6    18   */
/*     |  |  | (6) |(7)|          |              |    |    */
/*     |  ^  +--------------------+              |    v    */
/*     |  |        3  11                         ^    |    */
/*     |  |     c4+v  ^c8-                       |    |    */
/*     |  \---15----14----<-------19--\          |    |    */
/*     |           |  10              \-----<---------/    */
/*     |           4>--|-->\                     |c6-      */
/*     v           c5- |   |                     |         */
/*     |               |   5                     |         */
/*     \------>--9-----/   \-------->---5--------/         */
/*                                                         */
/*                                                         */
/*                                                         */
		       	
pd_idx_t nedges = 4;            
pd_idx_t tangle_faces[4] = {5 ,6,7 ,1};
pd_idx_t tangle_edges[4] = {12,3,11,2};

pd_idx_t noverstrand_edges = 3;
pd_idx_t overstrand_edges[3] = {14,15,16};
pd_idx_t border_faces[3]     = {7,6,5};

bool valid_ts_input = true; 

pd_idx_t tangle_slide_edges[2] = {3,12};
pd_idx_t complementary_edges[3] = {11,2};
pd_boundary_or_t complementary_or[3] = {in,out};
bool overstrand_goes_OVER = true;
pd_or_t overstrand_orientation = PD_NEG_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test W\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testW_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test W : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test X assembled c code */

pd_code_t *pd_create_tangle_slide_input_testX_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(5);
assert(pd != NULL);
pd->ncross = 5;
pd->nedges = 10;
pd->ncomps = 3;
pd->nfaces = 7;
sprintf(pd->hash,"%s","BQoHBgQDAgICAQMEBAIAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 3;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 6;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 5;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 6;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 7;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 4;
pd->cross[3].edge[1] = 8;
pd->cross[3].edge[2] = 5;
pd->cross[3].edge[3] = 9;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 9;
pd->cross[4].edge[2] = 7;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 0;
pd->edge[3].headpos = 2;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 3;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 0;

pd->edge[5].head = 1;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 3;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 2;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 4;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 2;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 3;
pd->edge[8].headpos = 1;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 4;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 3;
pd->edge[9].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 4;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 4;
pd->comp[1].edge[1] = 5;
pd->comp[1].edge[2] = 6;
pd->comp[1].edge[3] = 7;

pd->comp[2].nedges = 2;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 8;
pd->comp[2].edge[1] = 9;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 5;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 8;
pd->face[0].or[2] = 0;

pd->face[0].edge[3] = 7;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 2;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 3;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 7;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 5;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 0;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 2;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 6;
pd->face[2].or[2] = 0;

pd->face[3].nedges = 2;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 1;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 6;
pd->face[3].or[1] = 1;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 4;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 9;
pd->face[5].or[1] = 1;

pd->face[6].nedges = 1;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testX() {

  /*                                                         */
/*                                                         */
/*                   /--3--\                               */
/*                   A     ^                               */
/*                   | (6) |c0                             */
/*                   \-3>--|-->-\          (0)             */
/*                         2    0                          */
/*                      c2 | (2)|c1                        */
/*                /----7-----<6----5----\                  */
/*                |        |    |       |                  */
/*                |  T     ^ (3)v       |                  */
/*                B  +---------------+  ^                  */
/*                |  |     \--1-/    |  |                  */
/*                |  |       (1)     |  |                  */
/*                7  |               |  |                  */
/*                |  |  /-C--9----\  |  |                  */
/*                v  +---------------+  |                  */
/*                |     v   (5)   ^     |                  */
/*                |     |         |     |                  */
/*                \7---------4-->-----5-/                  */
/*                   c4 |         |c3                      */
/*                      C   (4)   |                        */
/*                      \----8-->-/                        */
		       
pd_idx_t nedges = 4 ;            
pd_idx_t tangle_faces[4] = {3,1,5,1};
pd_idx_t tangle_edges[4] = {1,9,9,1};

pd_idx_t noverstrand_edges = 3;
pd_idx_t overstrand_edges[3] = {7,4,5};
pd_idx_t border_faces[3]     = {1,5,1};

bool valid_ts_input = true ; 

pd_idx_t tangle_slide_edges[2] = {9,9};
pd_idx_t complementary_edges[3] = {1,1};
pd_boundary_or_t complementary_or[3] = {out,in};
bool overstrand_goes_OVER = true;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test X\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testX_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test X : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test Y assembled c code */

pd_code_t *pd_create_tangle_slide_input_testY_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(5);
assert(pd != NULL);
pd->ncross = 5;
pd->nedges = 10;
pd->ncomps = 3;
pd->nfaces = 7;
sprintf(pd->hash,"%s","BQoHBgQDAgICAQMEBAIAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 3;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 6;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 5;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 6;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 7;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 4;
pd->cross[3].edge[1] = 8;
pd->cross[3].edge[2] = 5;
pd->cross[3].edge[3] = 9;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 9;
pd->cross[4].edge[2] = 7;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 0;
pd->edge[3].headpos = 2;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 3;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 0;

pd->edge[5].head = 1;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 3;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 2;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 4;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 2;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 3;
pd->edge[8].headpos = 1;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 4;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 3;
pd->edge[9].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 4;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 4;
pd->comp[1].edge[1] = 5;
pd->comp[1].edge[2] = 6;
pd->comp[1].edge[3] = 7;

pd->comp[2].nedges = 2;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 8;
pd->comp[2].edge[1] = 9;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 5;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 8;
pd->face[0].or[2] = 0;

pd->face[0].edge[3] = 7;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 2;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 3;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 7;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 5;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 0;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 2;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 6;
pd->face[2].or[2] = 0;

pd->face[3].nedges = 2;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 1;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 6;
pd->face[3].or[1] = 1;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 4;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 9;
pd->face[5].or[1] = 1;

pd->face[6].nedges = 1;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testY() {

  /*                                                         */
/*                                                         */
/*                   /--3--\                               */
/*                   A     ^                               */
/*                   | (6) |c0                             */
/*                   \-3>--|-->-\          (0)             */
/*                         2    0                          */
/*                      c2 | (2)|c1                        */
/*                /----7-----<6----5----\                  */
/*                |        |    |       |                  */
/*                |  T     ^ (3)v       |                  */
/*                B  +---------------+  ^                  */
/*                |  |     \--1-/    |  |                  */
/*                |  |       (1)     |  |                  */
/*                7  |               |  |                  */
/*                |  |  /-C--9----\  |  |                  */
/*                v  +---------------+  |                  */
/*                |     v   (5)   ^     |                  */
/*                |     |         |     |                  */
/*                \7---------4-->-----5-/                  */
/*                   c4 |         |c3                      */
/*                      C   (4)   |                        */
/*                      \----8-->-/                        */
		       
pd_idx_t nedges = 4 ;            
pd_idx_t tangle_faces[4] = {3,1,5,1};
pd_idx_t tangle_edges[4] = {1,9,9,1};

pd_idx_t noverstrand_edges = 3;
pd_idx_t overstrand_edges[3] = {6,7,4};
pd_idx_t border_faces[3]     = {3,1,5};

bool valid_ts_input = true ; 

pd_idx_t tangle_slide_edges[2] = {1,9};
pd_idx_t complementary_edges[3] = {1,9};
pd_boundary_or_t complementary_or[3] = {in,out};
bool overstrand_goes_OVER = true;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test Y\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testY_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test Y : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test Z assembled c code */

pd_code_t *pd_create_tangle_slide_input_testZ_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(5);
assert(pd != NULL);
pd->ncross = 5;
pd->nedges = 10;
pd->ncomps = 3;
pd->nfaces = 7;
sprintf(pd->hash,"%s","BQoHBgQDAgICAQMEBAIAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 3;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 6;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 5;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 6;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 7;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 4;
pd->cross[3].edge[1] = 8;
pd->cross[3].edge[2] = 5;
pd->cross[3].edge[3] = 9;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 9;
pd->cross[4].edge[2] = 7;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 0;
pd->edge[3].headpos = 2;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 3;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 0;

pd->edge[5].head = 1;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 3;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 2;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 4;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 2;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 3;
pd->edge[8].headpos = 1;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 4;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 3;
pd->edge[9].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 4;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 4;
pd->comp[1].edge[1] = 5;
pd->comp[1].edge[2] = 6;
pd->comp[1].edge[3] = 7;

pd->comp[2].nedges = 2;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 8;
pd->comp[2].edge[1] = 9;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 5;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 8;
pd->face[0].or[2] = 0;

pd->face[0].edge[3] = 7;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 2;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 3;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 7;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 5;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 0;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 2;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 6;
pd->face[2].or[2] = 0;

pd->face[3].nedges = 2;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 1;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 6;
pd->face[3].or[1] = 1;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 4;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 9;
pd->face[5].or[1] = 1;

pd->face[6].nedges = 1;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testZ() {

  /*                                                         */
/*                                                         */
/*                   /--3--\                               */
/*                   A     ^                               */
/*                   | (6) |c0                             */
/*                   \-3>--|-->-\          (0)             */
/*                         2    0                          */
/*                      c2 | (2)|c1                        */
/*                /----7-----<6----5----\                  */
/*                |        |    |       |                  */
/*                |  T     ^ (3)v       |                  */
/*                B  +---------------+  ^                  */
/*                |  |     \--1-/    |  |                  */
/*                |  |       (1)     |  |                  */
/*                7  |               |  |                  */
/*                |  |  /-C--9----\  |  |                  */
/*                v  +---------------+  |                  */
/*                |     v   (5)   ^     |                  */
/*                |     |         |     |                  */
/*                \7---------4-->-----5-/                  */
/*                   c4 |         |c3                      */
/*                      C   (4)   |                        */
/*                      \----8-->-/                        */
		       
pd_idx_t nedges = 4 ;            
pd_idx_t tangle_faces[4] = {3,1,5,1};
pd_idx_t tangle_edges[4] = {1,9,9,1};

pd_idx_t noverstrand_edges = 2;
pd_idx_t overstrand_edges[2] = {7,4};
pd_idx_t border_faces[2] = {1,5};

bool valid_ts_input = true ; 

pd_idx_t tangle_slide_edges[1] = {9};
pd_idx_t complementary_edges[3] = {1,1,9};
pd_boundary_or_t complementary_or[3] = {out,in,in};
bool overstrand_goes_OVER = true;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test Z\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testZ_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test Z : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test a assembled c code */

pd_code_t *pd_create_tangle_slide_input_testa_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(9);
assert(pd != NULL);
pd->ncross = 9;
pd->nedges = 18;
pd->ncomps = 1;
pd->nfaces = 11;
sprintf(pd->hash,"%s","CRILBgQEAwMDAwMDAgIBEgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 17;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 9;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 10;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 11;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 10;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 13;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 7;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 15;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 16;
pd->cross[6].sign = 1;

pd->cross[7].edge[0] = 8;
pd->cross[7].edge[1] = 14;
pd->cross[7].edge[2] = 9;
pd->cross[7].edge[3] = 13;
pd->cross[7].sign = 0;

pd->cross[8].edge[0] = 11;
pd->cross[8].edge[1] = 16;
pd->cross[8].edge[2] = 12;
pd->cross[8].edge[3] = 17;
pd->cross[8].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 4;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 7;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 1;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 7;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 2;
pd->edge[10].headpos = 3;
pd->edge[10].tail = 1;
pd->edge[10].tailpos = 3;

pd->edge[11].head = 8;
pd->edge[11].headpos = 0;
pd->edge[11].tail = 2;
pd->edge[11].tailpos = 1;

pd->edge[12].head = 3;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 8;
pd->edge[12].tailpos = 2;

pd->edge[13].head = 7;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 7;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 6;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 8;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 6;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 0;
pd->edge[17].headpos = 2;
pd->edge[17].tail = 8;
pd->edge[17].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 18;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 9;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 14;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 16;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 11;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 3;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 13;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 9;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 4;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 12;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 16;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 7;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 10;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 2;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 11;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 17;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 17;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 4;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 8;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 5;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 15;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 14;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 8;
pd->face[8].or[2] = 0;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 1;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 6;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 15;
pd->face[10].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testa() {

  /*                           _____<1___                                  */
/*                             /          \                                 */
/*                             |           \                                */
/*                             |    (9)     \                               */
/*                              |            |                               */
/*                  ___<11_____________<10____|_______________                */
/*      (0)        /             |2           |1              \               */
/*                /              |            |                0              */
/*               /               2            /                 0             */
/*               |     (4)       v    (3)    /                   0            */
/*               |               |          /                     \           */
/*               |    +----------|---------/------+ (1)            ^          */
/*               \    |      17>_|____0>__/       |                 9         */
/*                \   |     /    3 0              |                  \        */
/*                 \  |    / (5) v                |<-T                0       */
/*                  \_____/__12>_____________13>_________________     0       */
/*                    |  / 8     4 3              |              \    0       */
/*             ___16>___/(2)     v     (6)        |               \   0       */
/*            /       +----------|----------------+               |   /       */
/*       0000000000007>00000000000000000000008>0000000000000000000000/        */
/*      /   /6                   |4                               |7          */
/*     /   /                     |                                /           */
/*    /   /                      5                               /            */
/*    |   |          (7)         v            (8)               /             */
/*    |   |                      |                             /              */
/*    |   \                      |                            /               */
/*    |    \_______<15____________________________<14________/                */
/*    |                          /5                                           */
/*    |         (10)            /                                             */
/*    \___________________<6___/                                              */

pd_idx_t nedges = 6 ;            
pd_idx_t tangle_faces[6] = {0, 2, 6,1,3, 4};
pd_idx_t tangle_edges[6] = {16,4,13,0,2,11};

pd_idx_t noverstrand_edges = 4;
pd_idx_t overstrand_edges[4] = {6,7,8,9};
pd_idx_t border_faces[4] = {0,2,6,1};

bool valid_ts_input = true ; /* overstrand goes over */

pd_idx_t tangle_slide_edges[3] = {16,4,13};
pd_idx_t complementary_edges[2] = {11,2};
pd_boundary_or_t complementary_or[2] = {in,out};

bool overstrand_goes_OVER = true;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;




  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test a\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testa_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test a : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test b assembled c code */

pd_code_t *pd_create_tangle_slide_input_testb_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(9);
assert(pd != NULL);
pd->ncross = 9;
pd->nedges = 18;
pd->ncomps = 1;
pd->nfaces = 11;
sprintf(pd->hash,"%s","CRILBgQEAwMDAwMDAgIBEgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 17;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 9;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 10;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 11;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 10;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 13;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 7;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 15;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 16;
pd->cross[6].sign = 1;

pd->cross[7].edge[0] = 8;
pd->cross[7].edge[1] = 14;
pd->cross[7].edge[2] = 9;
pd->cross[7].edge[3] = 13;
pd->cross[7].sign = 0;

pd->cross[8].edge[0] = 11;
pd->cross[8].edge[1] = 16;
pd->cross[8].edge[2] = 12;
pd->cross[8].edge[3] = 17;
pd->cross[8].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 4;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 7;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 1;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 7;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 2;
pd->edge[10].headpos = 3;
pd->edge[10].tail = 1;
pd->edge[10].tailpos = 3;

pd->edge[11].head = 8;
pd->edge[11].headpos = 0;
pd->edge[11].tail = 2;
pd->edge[11].tailpos = 1;

pd->edge[12].head = 3;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 8;
pd->edge[12].tailpos = 2;

pd->edge[13].head = 7;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 7;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 6;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 8;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 6;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 0;
pd->edge[17].headpos = 2;
pd->edge[17].tail = 8;
pd->edge[17].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 18;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 9;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 14;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 16;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 11;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 3;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 13;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 9;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 4;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 12;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 16;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 7;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 10;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 2;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 11;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 17;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 17;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 4;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 8;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 5;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 15;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 14;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 8;
pd->face[8].or[2] = 0;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 1;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 6;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 15;
pd->face[10].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testb() {

  /*                                _____<1___                                  */
/*                               /          \                                 */
/*                               |           \                                */
/*                               |    (9)     \                               */
/*                               |            |                               */
/*                  ___<11_____________<10____|_______________                */
/*      (0)        /             |2           |1              \               */
/*                /              |            |                \              */
/*               /               2            /                 \             */
/*               |     (4)       v    (3)    /                   \            */
/*               |               |          /                     \           */
/*               |    +----------|---------/------+ (1)            ^          */
/*               \    |      17>_|____0>__/       |                 9         */
/*                \   |     /    3 0              |                  \        */
/*                 \  |    / (5) v                |<-T                \       */
/*                  \_____/__12>_____________13>_________________     |       */
/*                    |  / 8     4 3              |              \    |       */
/*             ___16>___/(2)     v     (6)        |               \   |       */
/*            /       +----------|----------------+               |   /       */
/*       0000000000007>0000000000|000000000008>0000000000000000000000/        */
/*      /   /6                   |4                               |7          */
/*     /   /                     |                                /           */
/*    /   /                      5                               /            */
/*    |   |          (7)         v            (8)               /             */
/*    |   |                      |                             /              */
/*    |   \                      |                            /               */
/*    |    \_______<15____________________________<14________/                */
/*    |                          /5                                           */
/*    |         (10)            /                                             */
/*    \___________________<6___/                                              */

pd_idx_t nedges = 6 ;            
pd_idx_t tangle_faces[6] = {0,2,6,1,3,4} ;
pd_idx_t tangle_edges[6] = {16,4,13,0,2,11} ;

pd_idx_t noverstrand_edges = 4;
pd_idx_t overstrand_edges[4] = {6,7,8,9};
pd_idx_t border_faces[4] = {0,2,6,1};

bool valid_ts_input = false ; /* crossings on overstrand edges don't match */

pd_idx_t tangle_slide_edges[1] = {PD_UNSET_IDX};
pd_idx_t complementary_edges[1] = {PD_UNSET_IDX};
pd_boundary_or_t complementary_or[1] = {unset};
bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_UNSET_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test b\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testb_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test b : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test c assembled c code */

pd_code_t *pd_create_tangle_slide_input_testc_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(9);
assert(pd != NULL);
pd->ncross = 9;
pd->nedges = 18;
pd->ncomps = 1;
pd->nfaces = 11;
sprintf(pd->hash,"%s","CRILBgQEAwMDAwMDAgIBEgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 17;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 9;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 10;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 11;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 10;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 13;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 7;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 15;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 16;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 8;
pd->cross[7].edge[1] = 14;
pd->cross[7].edge[2] = 9;
pd->cross[7].edge[3] = 13;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 11;
pd->cross[8].edge[1] = 16;
pd->cross[8].edge[2] = 12;
pd->cross[8].edge[3] = 17;
pd->cross[8].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 4;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 7;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 1;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 7;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 2;
pd->edge[10].headpos = 3;
pd->edge[10].tail = 1;
pd->edge[10].tailpos = 3;

pd->edge[11].head = 8;
pd->edge[11].headpos = 0;
pd->edge[11].tail = 2;
pd->edge[11].tailpos = 1;

pd->edge[12].head = 3;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 8;
pd->edge[12].tailpos = 2;

pd->edge[13].head = 7;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 7;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 6;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 8;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 6;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 0;
pd->edge[17].headpos = 2;
pd->edge[17].tail = 8;
pd->edge[17].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 18;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 9;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 14;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 16;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 11;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 3;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 13;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 9;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 4;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 12;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 16;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 7;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 10;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 2;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 11;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 17;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 17;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 4;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 8;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 5;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 15;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 14;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 8;
pd->face[8].or[2] = 0;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 1;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 6;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 15;
pd->face[10].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testc() {

  /*                                _____<1___                                  */
/*                               /          \                                 */
/*                               |           \                                */
/*                               |    (9)     \                               */
/*                               |            |                               */
/*                  ___<11_____________<10____|_______________                */
/*      (0)        /             |2           |1              \               */
/*                /              |            |                \              */
/*               /               2            /                 \             */
/*               |     (4)       v    (3)    /                   \            */
/*               |               |          /                     \           */
/*               |    +----------|---------/------+ (1)            ^          */
/*               \    |      17>_|____0>__/       |                 9         */
/*                \   |     /    3 0              |                  \        */
/*                 \  |    / (5) v                |<-T                \       */
/*                  \_____/__12>_____________13>_________________     |       */
/*                    |  / 8     4 3              |              \    |       */
/*             ___16>___/(2)     v     (6)        |               \   |       */
/*            /       +----------|----------------+               |   /       */
/*       0000/00000007>0000000000|000000000008>0000000000000000000|00/        */
/*      /   /6                   |4                               |7          */
/*     /   /                     |                                /           */
/*    /   /                      5                               /            */
/*    |   |          (7)         v            (8)               /             */
/*    |   |                      |                             /              */
/*    |   \                      |                            /               */
/*    |    \_______<15____________________________<14________/                */
/*    |                          /5                                           */
/*    |         (10)            /                                             */
/*    \___________________<6___/                                              */

pd_idx_t nedges = 6 ;            
pd_idx_t tangle_faces[6] = {0,2,6,1,3,4} ;
pd_idx_t tangle_edges[6] = {16,4,13,0,2,11} ;

pd_idx_t noverstrand_edges = 4;
pd_idx_t overstrand_edges[4] = {6,7,8,9};
pd_idx_t border_faces[4] = {0,2,6,1};

bool valid_ts_input = true ; /* overstrand goes under */

pd_idx_t tangle_slide_edges[3] = {16,4,13};
pd_idx_t complementary_edges[2] = {11,2};
pd_boundary_or_t complementary_or[2] = {in,out};

bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test c\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testc_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test c : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test d assembled c code */

pd_code_t *pd_create_tangle_slide_input_testd_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(9);
assert(pd != NULL);
pd->ncross = 9;
pd->nedges = 18;
pd->ncomps = 1;
pd->nfaces = 11;
sprintf(pd->hash,"%s","CRILBgQEAwMDAwMDAgIBEgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 17;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 9;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 10;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 11;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 10;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 13;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 7;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 15;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 16;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 8;
pd->cross[7].edge[1] = 14;
pd->cross[7].edge[2] = 9;
pd->cross[7].edge[3] = 13;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 11;
pd->cross[8].edge[1] = 16;
pd->cross[8].edge[2] = 12;
pd->cross[8].edge[3] = 17;
pd->cross[8].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 4;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 7;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 1;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 7;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 2;
pd->edge[10].headpos = 3;
pd->edge[10].tail = 1;
pd->edge[10].tailpos = 3;

pd->edge[11].head = 8;
pd->edge[11].headpos = 0;
pd->edge[11].tail = 2;
pd->edge[11].tailpos = 1;

pd->edge[12].head = 3;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 8;
pd->edge[12].tailpos = 2;

pd->edge[13].head = 7;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 7;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 6;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 8;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 6;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 0;
pd->edge[17].headpos = 2;
pd->edge[17].tail = 8;
pd->edge[17].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 18;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 9;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 14;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 16;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 11;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 3;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 13;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 9;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 4;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 12;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 16;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 7;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 10;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 2;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 11;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 17;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 17;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 4;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 8;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 5;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 15;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 14;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 8;
pd->face[8].or[2] = 0;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 1;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 6;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 15;
pd->face[10].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testd() {

  /*                                _____<1___                                  */
/*                               /          \                                 */
/*                               |           \                                */
/*                               |    (9)     \                               */
/*                               |            |                               */
/*                  ___<11_____________<10____|_______________                */
/*      (0)        /             |2           |1              \               */
/*                /              |            |                \              */
/*               /               2            /                 \             */
/*               |     (4)       v    (3)    /                   \            */
/*               |               |          /                     \           */
/*               |    +----------|---------/------+ (1)            ^          */
/*               \    |      17>_|____0>__/       |                 9         */
/*                \   |     /    3 0              |                  \        */
/*                 \  |    / (5) v                |<-T                \       */
/*                  \_____/__12>_____________13>_________________     |       */
/*                    |  / 8     4 3              |              \    |       */
/*             ___16>___/(2)     v     (6)        |               \   |       */
/*            /       +----------|----------------+               |   /       */
/*       0000/00000007>0000000000|000000000008>0000000000000000000|00/        */
/*      /   /6                   |4                               |7          */
/*     /   /                     |                                /           */
/*    /   /                      5                               /            */
/*    |   |          (7)         v            (8)               /             */
/*    |   |                      |                             /              */
/*    |   \                      |                            /               */
/*    |    \_______<15____________________________<14________/                */
/*    |                          /5                                           */
/*    |         (10)            /                                             */
/*    \___________________<6___/                                              */

pd_idx_t nedges = 6 ;            
pd_idx_t tangle_faces[6] = {0,2,6,1,3,4} ;
pd_idx_t tangle_edges[6] = {16,4,13,0,2,11} ;

pd_idx_t noverstrand_edges = 4;
pd_idx_t overstrand_edges[4] = {6,7,8,9};
pd_idx_t border_faces[4] = {10,7,8,0};

bool valid_ts_input = false ; /* incorrect input: faces don't touch tangle */

pd_idx_t tangle_slide_edges[1] = {PD_UNSET_IDX};
pd_idx_t complementary_edges[1] = {PD_UNSET_IDX};
pd_boundary_or_t complementary_or[1] = {unset};
bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_UNSET_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test d\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testd_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test d : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test e assembled c code */

pd_code_t *pd_create_tangle_slide_input_teste_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(9);
assert(pd != NULL);
pd->ncross = 9;
pd->nedges = 18;
pd->ncomps = 1;
pd->nfaces = 11;
sprintf(pd->hash,"%s","CRILBgQEAwMDAwMDAgIBEgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 17;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 9;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 10;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 11;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 10;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 13;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 7;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 15;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 16;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 8;
pd->cross[7].edge[1] = 14;
pd->cross[7].edge[2] = 9;
pd->cross[7].edge[3] = 13;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 11;
pd->cross[8].edge[1] = 16;
pd->cross[8].edge[2] = 12;
pd->cross[8].edge[3] = 17;
pd->cross[8].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 4;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 7;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 4;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 1;
pd->edge[9].headpos = 1;
pd->edge[9].tail = 7;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 2;
pd->edge[10].headpos = 3;
pd->edge[10].tail = 1;
pd->edge[10].tailpos = 3;

pd->edge[11].head = 8;
pd->edge[11].headpos = 0;
pd->edge[11].tail = 2;
pd->edge[11].tailpos = 1;

pd->edge[12].head = 3;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 8;
pd->edge[12].tailpos = 2;

pd->edge[13].head = 7;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 7;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 6;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 8;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 6;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 0;
pd->edge[17].headpos = 2;
pd->edge[17].tail = 8;
pd->edge[17].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 18;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 9;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 14;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 16;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 11;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 3;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 13;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 9;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 4;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 12;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 16;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 7;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 10;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 2;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 11;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 17;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 17;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 4;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 8;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 5;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 15;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 14;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 8;
pd->face[8].or[2] = 0;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 1;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 6;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 15;
pd->face[10].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_teste() {

  /*                                _____<1___                                  */
/*                               /          \                                 */
/*                               |           \                                */
/*                               |    (9)     \                               */
/*                               |            |                               */
/*                  ___<11_____________<10____|_______________                */
/*      (0)        /             |2           |1              \               */
/*                /              |            |                \              */
/*               /               2            /                 \             */
/*               |     (4)       v    (3)    /                   \            */
/*               |               |          /                     \           */
/*               |    +----------|---------/------+ (1)            ^          */
/*               \    |      17>_|____0>__/       |                 9         */
/*                \   |     /    3 0              |                  \        */
/*                 \  |    / (5) v                |<-T                \       */
/*                  \_____/__12>_____________13>_________________     |       */
/*                    |  / 8     4 3              |              \    |       */
/*             ___16>___/(2)     v     (6)        |               \   |       */
/*            /       +----------|----------------+               |   /       */
/*       0000/00000007>0000000000|000000000008>0000000000000000000|00/        */
/*      /   /6                   |4                               |7          */
/*     /   /                     |                                /           */
/*    /   /                      5                               /            */
/*    |   |          (7)         v            (8)               /             */
/*    |   |                      |                             /              */
/*    |   \                      |                            /               */
/*    |    \_______<15____________________________<14________/                */
/*    |                          /5                                           */
/*    |         (10)            /                                             */
/*    \___________________<6___/                                              */

pd_idx_t nedges = 6 ;            
pd_idx_t tangle_faces[6] = {0,2,6,1,3,4} ;
pd_idx_t tangle_edges[6] = {16,4,13,0,2,11} ;

pd_idx_t noverstrand_edges = 4;
pd_idx_t overstrand_edges[4] = {4,7,8,9};
pd_idx_t border_faces[4] = {0,2,6,1};

bool valid_ts_input = false ; /* incorrect input overstrand edges */

pd_idx_t tangle_slide_edges[1] = {PD_UNSET_IDX};
pd_idx_t complementary_edges[1] = {PD_UNSET_IDX};
pd_boundary_or_t complementary_or[1] = {unset};
bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_UNSET_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test e\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_teste_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test e : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test f assembled c code */

pd_code_t *pd_create_tangle_slide_input_testf_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(12);
assert(pd != NULL);
pd->ncross = 12;
pd->nedges = 24;
pd->ncomps = 1;
pd->nfaces = 14;
sprintf(pd->hash,"%s","DBgOBwQEBAQEAwMDAwMCAgIBGAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 23;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 19;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 20;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 19;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 18;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 13;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 12;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 13;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 14;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 11;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 12;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 22;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 23;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 17;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 18;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 9;
pd->cross[9].edge[1] = 21;
pd->cross[9].edge[2] = 10;
pd->cross[9].edge[3] = 20;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 10;
pd->cross[10].edge[1] = 16;
pd->cross[10].edge[2] = 11;
pd->cross[10].edge[3] = 15;
pd->cross[10].sign = 1;

pd->cross[11].edge[0] = 16;
pd->cross[11].edge[1] = 21;
pd->cross[11].edge[2] = 17;
pd->cross[11].edge[3] = 22;
pd->cross[11].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 9;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 10;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 9;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 6;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 10;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 3;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 6;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 4;
pd->edge[13].headpos = 1;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 1;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 4;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 10;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 11;
pd->edge[16].headpos = 0;
pd->edge[16].tail = 10;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 8;
pd->edge[17].headpos = 1;
pd->edge[17].tail = 11;
pd->edge[17].tailpos = 2;

pd->edge[18].head = 2;
pd->edge[18].headpos = 3;
pd->edge[18].tail = 8;
pd->edge[18].tailpos = 3;

pd->edge[19].head = 1;
pd->edge[19].headpos = 1;
pd->edge[19].tail = 2;
pd->edge[19].tailpos = 1;

pd->edge[20].head = 9;
pd->edge[20].headpos = 3;
pd->edge[20].tail = 1;
pd->edge[20].tailpos = 3;

pd->edge[21].head = 11;
pd->edge[21].headpos = 1;
pd->edge[21].tail = 9;
pd->edge[21].tailpos = 1;

pd->edge[22].head = 7;
pd->edge[22].headpos = 1;
pd->edge[22].tail = 11;
pd->edge[22].tailpos = 3;

pd->edge[23].head = 0;
pd->edge[23].headpos = 2;
pd->edge[23].tail = 7;
pd->edge[23].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 24;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;
pd->comp[0].edge[18] = 18;
pd->comp[0].edge[19] = 19;
pd->comp[0].edge[20] = 20;
pd->comp[0].edge[21] = 21;
pd->comp[0].edge[22] = 22;
pd->comp[0].edge[23] = 23;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 20;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 10;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 15;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 5;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 13;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 3;
pd->face[0].or[6] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 18;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 20;
pd->face[1].or[3] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 2;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 23;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 8;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 18;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 3;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 12;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 23;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 14;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 6;
pd->face[4].or[2] = 1;

pd->face[4].edge[3] = 12;
pd->face[4].or[3] = 1;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 7;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 11;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 16;
pd->face[5].or[2] = 1;

pd->face[5].edge[3] = 22;
pd->face[5].or[3] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 0;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 2;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 19;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 6;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 15;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 11;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 8;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 22;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 17;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 3;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 9;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 17;
pd->face[9].or[1] = 0;

pd->face[9].edge[2] = 21;
pd->face[9].or[2] = 0;

pd->face[10].nedges = 3;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 10;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 21;
pd->face[10].or[1] = 1;

pd->face[10].edge[2] = 16;
pd->face[10].or[2] = 0;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 1;
pd->face[11].or[0] = 0;

pd->face[11].edge[1] = 19;
pd->face[11].or[1] = 0;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 4;
pd->face[12].or[0] = 0;

pd->face[12].edge[1] = 13;
pd->face[12].or[1] = 1;

pd->face[13].nedges = 2;
pd->face[13].edge = calloc(pd->face[13].nedges,sizeof(pd_idx_t));
pd->face[13].or = calloc(pd->face[13].nedges,sizeof(pd_or_t));
assert(pd->face[13].edge != NULL);
assert(pd->face[13].or != NULL);

pd->face[13].edge[0] = 5;
pd->face[13].or[0] = 1;

pd->face[13].edge[1] = 14;
pd->face[13].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testf() {

  /*                     __________20>___________________________               */
/*                    /                                        \              */
/*                   /                                          \             */
/*         (0)      /                             (1)           |             */
/*                 /     +--------------------+                 |             */
/*                 |     |                    |                 /             */
/*              __ | _1>_____                 |                /              */
/*             /   |1    |   \             ______________________             */
/*            /    |     |    \           ^   |                9 \            */
/*           /     \     |(11) \         9    |             /     \           */
/*          /       \    |      \        |    |   (9)      /       \          */
/*         /         \____<19__ | __<18_____  |           /        |          */
/*         |             |      |2       |8 \ |         21         |          */
/*         |    (6)      |      2        ^   ^|         v          /          */
/*         |             |      v  (2)   8    17       /          /           */
/*         \             |      |        |(8) | 0     /          /            */
/*          \_______________<0_____<23__ | _<22_ 0 __/   (10)  10             */
/*                       |      |0       ^ 7  |  011          v               */
/*                       |      3   (3)  7 (5)|  ^           /                */
/*                       |      v        |    |  16         /                 */
/*          ______________<13__ | __<12____<11__ 0 ________/                  */
/*         /             |      |3       |6   |  0 10                         */
/*        /              |      4   (4)  ^    |  0                            */
/*        \     (12)     +------v--------6----+  0                            */
/*         \                    |        |  (7)  0                            */
/*          \000000000000000000000014>000000015>0                             */
/*                              |4       |5                                   */
/*                              \  (13)  /                                    */
/*                               \__5>__/                                     */
pd_idx_t nedges = 10 ;            
pd_idx_t tangle_faces[10] = {0,12,4,7,5,8,9,1,11,6} ;
pd_idx_t tangle_edges[10] = {13,4,6,11,22,17,9,1,19,0} ;

pd_idx_t noverstrand_edges = 5;
pd_idx_t overstrand_edges[5] = {13,14,15,16,17};
pd_idx_t border_faces[5] = {12,4,7,5,8};

bool valid_ts_input = true ; /* overstrand goes over */

pd_idx_t tangle_slide_edges[4] = {4,6,11,22};
pd_idx_t complementary_edges[6] = {13,0,19,1,9,17};
pd_boundary_or_t complementary_or[6] = {out,out,out,in,out,in};
bool overstrand_goes_OVER = true;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test f\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testf_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test f : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test g assembled c code */

pd_code_t *pd_create_tangle_slide_input_testg_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(12);
assert(pd != NULL);
pd->ncross = 12;
pd->nedges = 24;
pd->ncomps = 1;
pd->nfaces = 14;
sprintf(pd->hash,"%s","DBgOBwQEBAQEAwMDAwMCAgIBGAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 23;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 19;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 20;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 19;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 18;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 13;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 12;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 13;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 14;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 11;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 12;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 22;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 23;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 17;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 18;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 9;
pd->cross[9].edge[1] = 21;
pd->cross[9].edge[2] = 10;
pd->cross[9].edge[3] = 20;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 10;
pd->cross[10].edge[1] = 16;
pd->cross[10].edge[2] = 11;
pd->cross[10].edge[3] = 15;
pd->cross[10].sign = 0;

pd->cross[11].edge[0] = 16;
pd->cross[11].edge[1] = 21;
pd->cross[11].edge[2] = 17;
pd->cross[11].edge[3] = 22;
pd->cross[11].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 9;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 10;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 9;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 6;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 10;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 3;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 6;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 4;
pd->edge[13].headpos = 1;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 1;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 4;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 10;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 11;
pd->edge[16].headpos = 0;
pd->edge[16].tail = 10;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 8;
pd->edge[17].headpos = 1;
pd->edge[17].tail = 11;
pd->edge[17].tailpos = 2;

pd->edge[18].head = 2;
pd->edge[18].headpos = 3;
pd->edge[18].tail = 8;
pd->edge[18].tailpos = 3;

pd->edge[19].head = 1;
pd->edge[19].headpos = 1;
pd->edge[19].tail = 2;
pd->edge[19].tailpos = 1;

pd->edge[20].head = 9;
pd->edge[20].headpos = 3;
pd->edge[20].tail = 1;
pd->edge[20].tailpos = 3;

pd->edge[21].head = 11;
pd->edge[21].headpos = 1;
pd->edge[21].tail = 9;
pd->edge[21].tailpos = 1;

pd->edge[22].head = 7;
pd->edge[22].headpos = 1;
pd->edge[22].tail = 11;
pd->edge[22].tailpos = 3;

pd->edge[23].head = 0;
pd->edge[23].headpos = 2;
pd->edge[23].tail = 7;
pd->edge[23].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 24;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;
pd->comp[0].edge[18] = 18;
pd->comp[0].edge[19] = 19;
pd->comp[0].edge[20] = 20;
pd->comp[0].edge[21] = 21;
pd->comp[0].edge[22] = 22;
pd->comp[0].edge[23] = 23;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 20;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 10;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 15;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 5;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 13;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 3;
pd->face[0].or[6] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 18;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 20;
pd->face[1].or[3] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 2;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 23;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 8;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 18;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 3;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 12;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 23;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 14;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 6;
pd->face[4].or[2] = 1;

pd->face[4].edge[3] = 12;
pd->face[4].or[3] = 1;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 7;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 11;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 16;
pd->face[5].or[2] = 1;

pd->face[5].edge[3] = 22;
pd->face[5].or[3] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 0;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 2;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 19;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 6;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 15;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 11;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 8;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 22;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 17;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 3;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 9;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 17;
pd->face[9].or[1] = 0;

pd->face[9].edge[2] = 21;
pd->face[9].or[2] = 0;

pd->face[10].nedges = 3;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 10;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 21;
pd->face[10].or[1] = 1;

pd->face[10].edge[2] = 16;
pd->face[10].or[2] = 0;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 1;
pd->face[11].or[0] = 0;

pd->face[11].edge[1] = 19;
pd->face[11].or[1] = 0;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 4;
pd->face[12].or[0] = 0;

pd->face[12].edge[1] = 13;
pd->face[12].or[1] = 1;

pd->face[13].nedges = 2;
pd->face[13].edge = calloc(pd->face[13].nedges,sizeof(pd_idx_t));
pd->face[13].or = calloc(pd->face[13].nedges,sizeof(pd_or_t));
assert(pd->face[13].edge != NULL);
assert(pd->face[13].or != NULL);

pd->face[13].edge[0] = 5;
pd->face[13].or[0] = 1;

pd->face[13].edge[1] = 14;
pd->face[13].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testg() {

  /*                     __________20>___________________________               */
/*                    /                                        \              */
/*                   /                                          \             */
/*         (0)      /                             (1)           |             */
/*                 /     +--------------------+                 |             */
/*                 |     |                    |                 /             */
/*              __ | _1>_____                 |                /              */
/*             /   |1    |   \             ______________________             */
/*            /    |     |    \           ^   |                9 \            */
/*           /     \     |(11) \         9    |             /     \           */
/*          /       \    |      \        |    |   (9)      /       \          */
/*         /         \____<19__ | __<18_____  |           /        |          */
/*         |             |      |2       |8 \ |         21         |          */
/*         |    (6)      |      2        ^   ^|         v          /          */
/*         |             |      v  (2)   8    17       /          /           */
/*         \             |      |        |(8) | 0     /          /            */
/*          \_______________<0_____<23__ | _<22_ 0 __/   (10)  10             */
/*                       |      |0       ^ 7  |  011          v               */
/*                       |      3   (3)  7 (5)|  ^           /                */
/*                       |      v        |    |  16         /                 */
/*          ______________<13__ | __<12____<11_____________/                  */
/*         /             |      |3       |6   |  0 10                         */
/*        /              |      4   (4)  ^    |  0                            */
/*        \     (12)     +------v--------6----+  0                            */
/*         \                    |        |  (7)  0                            */
/*          \0000000000000000000|0014>000000015>0                             */
/*                              |4       |5                                   */
/*                              \  (13)  /                                    */
/*                               \__5>__/                                     */
pd_idx_t nedges = 10 ;            
pd_idx_t tangle_faces[10] = {0,12,4,7,5,8,9,1,11,6} ;
pd_idx_t tangle_edges[10] = {13,4,6,11,22,17,9,1,19,0} ;

pd_idx_t noverstrand_edges = 5;
pd_idx_t overstrand_edges[5] = {13,14,15,16,17};
pd_idx_t border_faces[5] = {12,4,7,5,8};

bool valid_ts_input = false ; /* overstrand alternates under/over */

pd_idx_t tangle_slide_edges[1] = {PD_UNSET_IDX};
pd_idx_t complementary_edges[1] = {PD_UNSET_IDX};
pd_boundary_or_t complementary_or[1] = {unset};
bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_UNSET_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test g\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testg_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test g : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test h assembled c code */

pd_code_t *pd_create_tangle_slide_input_testh_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(12);
assert(pd != NULL);
pd->ncross = 12;
pd->nedges = 24;
pd->ncomps = 1;
pd->nfaces = 14;
sprintf(pd->hash,"%s","DBgOBwQEBAQEAwMDAwMCAgIBGAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 23;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 19;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 20;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 19;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 18;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 13;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 12;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 13;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 14;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 11;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 12;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 22;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 23;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 17;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 18;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 9;
pd->cross[9].edge[1] = 21;
pd->cross[9].edge[2] = 10;
pd->cross[9].edge[3] = 20;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 10;
pd->cross[10].edge[1] = 16;
pd->cross[10].edge[2] = 11;
pd->cross[10].edge[3] = 15;
pd->cross[10].sign = 0;

pd->cross[11].edge[0] = 16;
pd->cross[11].edge[1] = 21;
pd->cross[11].edge[2] = 17;
pd->cross[11].edge[3] = 22;
pd->cross[11].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 9;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 10;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 9;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 6;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 10;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 3;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 6;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 4;
pd->edge[13].headpos = 1;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 1;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 4;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 10;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 11;
pd->edge[16].headpos = 0;
pd->edge[16].tail = 10;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 8;
pd->edge[17].headpos = 1;
pd->edge[17].tail = 11;
pd->edge[17].tailpos = 2;

pd->edge[18].head = 2;
pd->edge[18].headpos = 3;
pd->edge[18].tail = 8;
pd->edge[18].tailpos = 3;

pd->edge[19].head = 1;
pd->edge[19].headpos = 1;
pd->edge[19].tail = 2;
pd->edge[19].tailpos = 1;

pd->edge[20].head = 9;
pd->edge[20].headpos = 3;
pd->edge[20].tail = 1;
pd->edge[20].tailpos = 3;

pd->edge[21].head = 11;
pd->edge[21].headpos = 1;
pd->edge[21].tail = 9;
pd->edge[21].tailpos = 1;

pd->edge[22].head = 7;
pd->edge[22].headpos = 1;
pd->edge[22].tail = 11;
pd->edge[22].tailpos = 3;

pd->edge[23].head = 0;
pd->edge[23].headpos = 2;
pd->edge[23].tail = 7;
pd->edge[23].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 24;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;
pd->comp[0].edge[18] = 18;
pd->comp[0].edge[19] = 19;
pd->comp[0].edge[20] = 20;
pd->comp[0].edge[21] = 21;
pd->comp[0].edge[22] = 22;
pd->comp[0].edge[23] = 23;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 20;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 10;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 15;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 5;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 13;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 3;
pd->face[0].or[6] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 18;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 20;
pd->face[1].or[3] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 2;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 23;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 8;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 18;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 3;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 12;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 23;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 14;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 6;
pd->face[4].or[2] = 1;

pd->face[4].edge[3] = 12;
pd->face[4].or[3] = 1;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 7;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 11;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 16;
pd->face[5].or[2] = 1;

pd->face[5].edge[3] = 22;
pd->face[5].or[3] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 0;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 2;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 19;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 6;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 15;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 11;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 8;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 22;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 17;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 3;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 9;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 17;
pd->face[9].or[1] = 0;

pd->face[9].edge[2] = 21;
pd->face[9].or[2] = 0;

pd->face[10].nedges = 3;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 10;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 21;
pd->face[10].or[1] = 1;

pd->face[10].edge[2] = 16;
pd->face[10].or[2] = 0;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 1;
pd->face[11].or[0] = 0;

pd->face[11].edge[1] = 19;
pd->face[11].or[1] = 0;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 4;
pd->face[12].or[0] = 0;

pd->face[12].edge[1] = 13;
pd->face[12].or[1] = 1;

pd->face[13].nedges = 2;
pd->face[13].edge = calloc(pd->face[13].nedges,sizeof(pd_idx_t));
pd->face[13].or = calloc(pd->face[13].nedges,sizeof(pd_or_t));
assert(pd->face[13].edge != NULL);
assert(pd->face[13].or != NULL);

pd->face[13].edge[0] = 5;
pd->face[13].or[0] = 1;

pd->face[13].edge[1] = 14;
pd->face[13].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testh() {

  /*                 |     |                    |                 /             */
/*              __ | _1>_____                 |                /              */
/*             /   |1    |   \             ______________________             */
/*            /    |     |    \           ^   |                9 \            */
/*           /     \     |(11) \         9    |             /     \           */
/*          /       \    |      \        |    |   (9)      /       \          */
/*         /         \____<19__ | __<18_____  |           /        |          */
/*         |             |      |2       |8 \ |         21         |          */
/*         |    (6)      |      2        ^   ^|         v          /          */
/*         |             |      v  (2)   8    17       /          /           */
/*         \             |      |        |(8) | 0     /          /            */
/*          \_______________<0_____<23__ | _<22______/   (10)  10             */
/*                       |      |0       ^ 7  |  011          v               */
/*                       |      3   (3)  7 (5)|  ^           /                */
/*                       |      v        |    |  16         /                 */
/*          ______________<13__ | __<12____<11_____________/                  */
/*         /             |      |3       |6   |  0 10                         */
/*        /              |      4   (4)  ^    |  0                            */
/*        \     (12)     +------v--------6----+  0                            */
/*         \                    |        |  (7)  0                            */
/*          \0000000000000000000|0014>000|00015>0                             */
/*                              |4       |5                                   */
/*                              \  (13)  /                                    */
/*                               \__5>__/                                     */
pd_idx_t nedges = 10 ;            
pd_idx_t tangle_faces[10] = {0,12,4,7,5,8,9,1,11,6} ;
pd_idx_t tangle_edges[10] = {13,4,6,11,22,17,9,1,19,0} ;

pd_idx_t noverstrand_edges = 5;
pd_idx_t overstrand_edges[5] = {13,14,15,16,17};
pd_idx_t border_faces[5] = {12,4,7,5,8};

bool valid_ts_input = true ; /* overstrand goes under */

pd_idx_t tangle_slide_edges[4] = {4,6,11,22};
pd_idx_t complementary_edges[6] = {13,0,19,1,9,17};
pd_boundary_or_t complementary_or[6] = {out,out,out,in,out,in};
bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_POS_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test h\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testh_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test h : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}

/* tangle interior test i assembled c code */

pd_code_t *pd_create_tangle_slide_input_testi_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(12);
assert(pd != NULL);
pd->ncross = 12;
pd->nedges = 24;
pd->ncomps = 1;
pd->nfaces = 14;
sprintf(pd->hash,"%s","DBgOBwQEBAQEAwMDAwMCAgIBGAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 3;
pd->cross[0].edge[2] = 23;
pd->cross[0].edge[3] = 2;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 19;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 20;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 19;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 18;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 13;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 12;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 13;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 14;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 14;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 11;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 12;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 22;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 23;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 17;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 18;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 9;
pd->cross[9].edge[1] = 21;
pd->cross[9].edge[2] = 10;
pd->cross[9].edge[3] = 20;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 10;
pd->cross[10].edge[1] = 16;
pd->cross[10].edge[2] = 11;
pd->cross[10].edge[3] = 15;
pd->cross[10].sign = 0;

pd->cross[11].edge[0] = 16;
pd->cross[11].edge[1] = 21;
pd->cross[11].edge[2] = 17;
pd->cross[11].edge[3] = 22;
pd->cross[11].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 3;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 1;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 9;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 10;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 9;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 6;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 10;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 3;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 6;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 4;
pd->edge[13].headpos = 1;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 1;

pd->edge[14].head = 5;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 4;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 10;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 11;
pd->edge[16].headpos = 0;
pd->edge[16].tail = 10;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 8;
pd->edge[17].headpos = 1;
pd->edge[17].tail = 11;
pd->edge[17].tailpos = 2;

pd->edge[18].head = 2;
pd->edge[18].headpos = 3;
pd->edge[18].tail = 8;
pd->edge[18].tailpos = 3;

pd->edge[19].head = 1;
pd->edge[19].headpos = 1;
pd->edge[19].tail = 2;
pd->edge[19].tailpos = 1;

pd->edge[20].head = 9;
pd->edge[20].headpos = 3;
pd->edge[20].tail = 1;
pd->edge[20].tailpos = 3;

pd->edge[21].head = 11;
pd->edge[21].headpos = 1;
pd->edge[21].tail = 9;
pd->edge[21].tailpos = 1;

pd->edge[22].head = 7;
pd->edge[22].headpos = 1;
pd->edge[22].tail = 11;
pd->edge[22].tailpos = 3;

pd->edge[23].head = 0;
pd->edge[23].headpos = 2;
pd->edge[23].tail = 7;
pd->edge[23].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 24;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;
pd->comp[0].edge[18] = 18;
pd->comp[0].edge[19] = 19;
pd->comp[0].edge[20] = 20;
pd->comp[0].edge[21] = 21;
pd->comp[0].edge[22] = 22;
pd->comp[0].edge[23] = 23;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 20;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 10;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 15;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 5;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 13;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 3;
pd->face[0].or[6] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 18;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 9;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 20;
pd->face[1].or[3] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 2;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 23;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 8;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 18;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 3;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 12;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 23;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 4;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 14;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 6;
pd->face[4].or[2] = 1;

pd->face[4].edge[3] = 12;
pd->face[4].or[3] = 1;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 7;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 11;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 16;
pd->face[5].or[2] = 1;

pd->face[5].edge[3] = 22;
pd->face[5].or[3] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 0;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 2;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 19;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 6;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 15;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 11;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 8;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 22;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 17;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 3;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 9;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 17;
pd->face[9].or[1] = 0;

pd->face[9].edge[2] = 21;
pd->face[9].or[2] = 0;

pd->face[10].nedges = 3;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 10;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 21;
pd->face[10].or[1] = 1;

pd->face[10].edge[2] = 16;
pd->face[10].or[2] = 0;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 1;
pd->face[11].or[0] = 0;

pd->face[11].edge[1] = 19;
pd->face[11].or[1] = 0;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 4;
pd->face[12].or[0] = 0;

pd->face[12].edge[1] = 13;
pd->face[12].or[1] = 1;

pd->face[13].nedges = 2;
pd->face[13].edge = calloc(pd->face[13].nedges,sizeof(pd_idx_t));
pd->face[13].or = calloc(pd->face[13].nedges,sizeof(pd_or_t));
assert(pd->face[13].edge != NULL);
assert(pd->face[13].or != NULL);

pd->face[13].edge[0] = 5;
pd->face[13].or[0] = 1;

pd->face[13].edge[1] = 14;
pd->face[13].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool pdint_check_tslide_data_ok_and_find_te_testi() {

  /*                 |     |                    |                 /             */
/*              __ | _1>_____                 |                /              */
/*             /   |1    |   \             ______________________             */
/*            /    |     |    \           ^   |                9 \            */
/*           /     \     |(11) \         9    |             /     \           */
/*          /       \    |      \        |    |   (9)      /       \          */
/*         /         \____<19__ | __<18_____  |           /        |          */
/*         |             |      |2       |8 \ |         21         |          */
/*         |    (6)      |      2        ^   ^|         v          /          */
/*         |             |      v  (2)   8    17       /          /           */
/*         \             |      |        |(8) | 0     /          /            */
/*          \_______________<0_____<23__ | _<22______/   (10)  10             */
/*                       |      |0       ^ 7  |  011          v               */
/*                       |      3   (3)  7 (5)|  ^           /                */
/*                       |      v        |    |  16         /                 */
/*          ______________<13__ | __<12____<11_____________/                  */
/*         /             |      |3       |6   |  0 10                         */
/*        /              |      4   (4)  ^    |  0                            */
/*        \     (12)     +------v--------6----+  0                            */
/*         \                    |        |  (7)  0                            */
/*          \0000000000000000000|0014>000|00015>0                             */
/*                              |4       |5                                   */
/*                              \  (13)  /                                    */
/*                               \__5>__/                                     */
pd_idx_t nedges = 10 ;            
pd_idx_t tangle_faces[10] = {0,12,4,7,5,8,9,1,11,6} ;
pd_idx_t tangle_edges[10] = {13,4,6,11,22,17,9,1,19,0} ;

pd_idx_t noverstrand_edges = 5;
pd_idx_t overstrand_edges[5] = {13,14,15,16,18};
pd_idx_t border_faces[5] = {12,4,7,5,8};

bool valid_ts_input = false ; /* overstrand edges aren't consecutive around outside of tangle*/

pd_idx_t tangle_slide_edges[1] = {PD_UNSET_IDX};
pd_idx_t complementary_edges[1] = {PD_UNSET_IDX};
pd_boundary_or_t complementary_or[1] = {unset};
bool overstrand_goes_OVER = false;
pd_or_t overstrand_orientation = PD_UNSET_ORIENTATION;


  printf("--------------------------------------------------\n"
    	 "pdint_check_tslide_data_ok_and_find_te test i\n"
	     "--------------------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_slide_input_testi_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");
  printf("running pdint_check_tslide_data_ok_and_find_te ");

  pd_idx_t completely_fake_memory_address;
  pd_idx_t *computed_tangle_slide_edges = &completely_fake_memory_address;
  /* We want to initialize this to something that's not NULL, since we need it
     to be NULL if the input data is invalid. */

  bool computed_overstrand_goes_OVER;
  pd_or_t computed_overstrand_orientation;

  pd_idx_t *computed_complementary_edges = &completely_fake_memory_address;
  pd_boundary_or_t *computed_complementary_or = &completely_fake_memory_address;
  
  bool computed_ts_input;

  if (valid_ts_input) {

    printf("(expect true)...");
    
  } else {

    printf("(expect false)...");

  }



  computed_ts_input
     = pdint_check_tslide_data_ok_and_find_te(pd,t,noverstrand_edges,
                                              overstrand_edges,
                                              border_faces,
                                              &computed_tangle_slide_edges,
                                              &computed_complementary_edges,
                                              &computed_complementary_or,
                                              &computed_overstrand_goes_OVER,
                                              &computed_overstrand_orientation);
                                                             
  if (computed_ts_input != valid_ts_input) {

     printf("FAIL");

     if (computed_ts_input) {

        printf(" (got true)\n");

     } else {

        printf(" (got false)\n");

     }

     return false;

  }

  printf("pass");

  if (computed_ts_input) {

        printf(" (got true)\n");

  } else {

        printf(" (got false)\n");

  }

  if (computed_ts_input) { /* If there ARE tangle edges, try to match them... */

    /*************** Tangle edges *******************/

    printf("checking address of computed_tangle_slide_edges...");
    if (computed_tangle_slide_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_tangle_slide_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed tangle_slide_edges against expected...");

    pd_idx_t i;

    for(i=0;i<noverstrand_edges-1;i++) {

     if (computed_tangle_slide_edges[i] != tangle_slide_edges[i]) {

        printf("FAIL.\nExpected and computed tangle edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",tangle_slide_edges[j]); }
        printf("\nComputed tangle edges: ");
        for(j=0;j<noverstrand_edges;j++) { printf("%4d ",computed_tangle_slide_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");

    /*************** Complementary Edges ******************/

    printf("checking address of computed_complementary_edges...");
    if (computed_complementary_edges == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_edges == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_edges against expected...");

    pd_idx_t Ncomplementary = t->nedges-(noverstrand_edges-1);

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary edges don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",complementary_edges[j]); }
        printf("\nComputed complementary edges: ");
        for(j=0;j<Ncomplementary;j++) { printf("%4d ",computed_complementary_edges[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists of edges match)\n");


    /*************** Complementary Orientations ******************/

    printf("checking address of computed_complementary_or...");
    if (computed_complementary_or == &completely_fake_memory_address) {

      printf("FAIL (not updated in call)\n");
      return false;

    }

    if (computed_complementary_or == NULL) {

      printf("FAIL (set to NULL, even though input is valid)\n");
      return false;

    }

    printf("pass (set to a new memory address != NULL)\n");

    printf("checking computed complementary_or against expected...");

    for(i=0;i<Ncomplementary;i++) {

      if (computed_complementary_edges[i] != complementary_edges[i]) {

        printf("FAIL.\nExpected and computed complementary orientations don't match at pos %d\n",i);

        pd_idx_t j;

        printf("Expected complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,complementary_or[j]); }
        printf("\nComputed complementary or: ");
        for(j=0;j<Ncomplementary;j++) {
           pd_printf("%BDY_OR ",NULL,computed_complementary_or[j]); }
        printf("\n                       ");
        for(j=0;j<i;j++) { printf("     "); }
        printf("-----\n");

        return false;

      }

    }

    printf("pass (lists match)\n");

    /************** overstrand_goes_OVER ***************/

    printf("checking computed overstrand_goes_OVER...");

    if (computed_overstrand_goes_OVER == overstrand_goes_OVER) {

       printf("pass (both are %s)\n",(overstrand_goes_OVER ? "true" : "false"));

    } else {

       printf("fail (expected %s, got %s)\n",
       (overstrand_goes_OVER ? "true" : "false"),
       (computed_overstrand_goes_OVER ? "true" : "false"));

       return false;

     }

     /************* overstrand_orientation **************/

    printf("checking computed overstrand_orientation...");

    if (computed_overstrand_orientation == overstrand_orientation) {

       pd_printf("pass (both are %OR)\n",NULL,&overstrand_orientation);

    } else {

       pd_printf("fail (expected %OR, got %OR)\n",NULL,
       &overstrand_orientation,&computed_overstrand_orientation);

       return false;

    }

  } else {

    printf("checking computed_tangle_slide_edges == NULL ...");

    if (computed_tangle_slide_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_edges == NULL ...");

    if (computed_complementary_edges != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

    printf("checking computed_complementary_or == NULL ...");

    if (computed_complementary_or != NULL) {

       printf("FAIL.\n");
       return false;

    }

    printf("pass\n");

  }
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);
  free(computed_tangle_slide_edges);
  free(computed_complementary_edges);
  free(computed_complementary_or);

  printf("done\n");

  printf("--------------------------------------------------------\n"
         "pdint_check_tslide_data_ok_and_find_te test i : PASS\n"
	     "--------------------------------------------------------\n");
  
  return true;

}


int main() {

  printf("test_tangle_slide_input (%s)\n",PACKAGE_STRING);
  printf("--------------------------------------------------------\n"
	 "Unit tests for pdint_check_tslide_data_ok_and_find_te(). \n"
	 "========================================================\n");

  if (pdint_check_tslide_data_ok_and_find_te_testW()&&pdint_check_tslide_data_ok_and_find_te_testX()&&pdint_check_tslide_data_ok_and_find_te_testY()&&pdint_check_tslide_data_ok_and_find_te_testZ()&&pdint_check_tslide_data_ok_and_find_te_testa()&&pdint_check_tslide_data_ok_and_find_te_testb()&&pdint_check_tslide_data_ok_and_find_te_testc()&&pdint_check_tslide_data_ok_and_find_te_testd()&&pdint_check_tslide_data_ok_and_find_te_teste()&&pdint_check_tslide_data_ok_and_find_te_testf()&&pdint_check_tslide_data_ok_and_find_te_testg()&&pdint_check_tslide_data_ok_and_find_te_testh()&&pdint_check_tslide_data_ok_and_find_te_testi()) {

    printf("=======================================================\n");
    printf("test_tangle_slide_input:  PASS.\n");
    exit(0);

  } else {

    printf("=====================================================\n");
    printf("test_tangle_slide_input:  FAIL.\n");
    exit(1);

  }

  return 0;

}