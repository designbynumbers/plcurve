pd_code_t *pd_create_tangle_slide_operation_testd_after_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(2);
assert(pd != NULL);
pd->ncross = 1;
pd->nedges = 2;
pd->ncomps = 1;
pd->nfaces = 3;
sprintf(pd->hash,"%s","AQIDAgEBAQIAAAAAAAAAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 0;
pd->cross[0].edge[2] = 1;
pd->cross[0].edge[3] = 1;
pd->cross[0].sign = 0;


/* Edge data */

pd->edge[0].head = 0;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 1;

pd->edge[1].head = 0;
pd->edge[1].headpos = 3;
pd->edge[1].tail = 0;
pd->edge[1].tailpos = 2;


/* Component Data */

pd->comp[0].nedges = 2;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;


/* Face data */

pd->face[0].nedges = 2;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 1;
pd->face[0].or[1] = 0;

pd->face[1].nedges = 1;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[2].nedges = 1;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}

pd_code_t *pd_create_tangle_slide_operation_testd_after_1() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(2);
assert(pd != NULL);
pd->ncross = 1;
pd->nedges = 2;
pd->ncomps = 1;
pd->nfaces = 3;
sprintf(pd->hash,"%s","AQIDAgEBAQIAAAAAAAAAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 0;
pd->cross[0].edge[2] = 1;
pd->cross[0].edge[3] = 1;
pd->cross[0].sign = 1;


/* Edge data */

pd->edge[0].head = 0;
pd->edge[0].headpos = 1;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 0;
pd->edge[1].headpos = 2;
pd->edge[1].tail = 0;
pd->edge[1].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 2;
pd->comp[0].tag = 'B';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;


/* Face data */

pd->face[0].nedges = 2;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 1;
pd->face[0].or[1] = 1;

pd->face[1].nedges = 1;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 1;

pd->face[2].nedges = 1;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}

