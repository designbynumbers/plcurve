
/*

   test_tangle_regenerate_auto.c : This code is auto-generated by 'assemble_tangleregentest.py' and shouldn't be edited by hand. It contains tests for the orientation and interior code in pd_regenerate_tangle.


*/

#ifdef HAVE_CONFIG_H
  #include"config.h"
#endif

#ifdef HAVE_STDIO_H
   #include<stdio.h>
#endif

#ifdef HAVE_ASSERT_H
   #include<assert.h>
#endif

#ifdef HAVE_STRING_H
   #include<string.h>
#endif

#ifdef HAVE_STDINT_H
   #include<stdint.h>
#endif

#ifdef HAVE_STDLIB_H
   #include<stdlib.h>
#endif

#ifdef HAVE_STDBOOL_H
   #include<stdbool.h>
#endif

#include<plcTopology.h>

/* tangle interior test a assembled c code */

pd_code_t *pd_create_tangle_testa_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(11);
assert(pd != NULL);
pd->ncross = 11;
pd->nedges = 22;
pd->ncomps = 4;
pd->nfaces = 13;
sprintf(pd->hash,"%s","CxYNBQUEBAQEAwMDAwICAgQKBAQEAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 5;
pd->cross[0].edge[2] = 9;
pd->cross[0].edge[3] = 4;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 21;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 18;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 16;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 15;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 16;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 17;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 21;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 20;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 18;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 19;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 11;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 12;
pd->cross[6].sign = 1;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 13;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 12;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 20;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 19;
pd->cross[8].sign = 1;

pd->cross[9].edge[0] = 10;
pd->cross[9].edge[1] = 14;
pd->cross[9].edge[2] = 11;
pd->cross[9].edge[3] = 15;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 10;
pd->cross[10].edge[1] = 17;
pd->cross[10].edge[2] = 13;
pd->cross[10].edge[3] = 14;
pd->cross[10].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 0;
pd->edge[4].headpos = 3;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 0;
pd->edge[5].tailpos = 1;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 0;
pd->edge[9].headpos = 2;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 9;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 10;
pd->edge[10].tailpos = 0;

pd->edge[11].head = 6;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 9;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 7;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 6;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 10;
pd->edge[13].headpos = 2;
pd->edge[13].tail = 7;
pd->edge[13].tailpos = 1;

pd->edge[14].head = 9;
pd->edge[14].headpos = 1;
pd->edge[14].tail = 10;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 2;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 9;
pd->edge[15].tailpos = 3;

pd->edge[16].head = 3;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 2;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 10;
pd->edge[17].headpos = 1;
pd->edge[17].tail = 3;
pd->edge[17].tailpos = 3;

pd->edge[18].head = 5;
pd->edge[18].headpos = 1;
pd->edge[18].tail = 1;
pd->edge[18].tailpos = 3;

pd->edge[19].head = 8;
pd->edge[19].headpos = 3;
pd->edge[19].tail = 5;
pd->edge[19].tailpos = 3;

pd->edge[20].head = 4;
pd->edge[20].headpos = 3;
pd->edge[20].tail = 8;
pd->edge[20].tailpos = 1;

pd->edge[21].head = 1;
pd->edge[21].headpos = 1;
pd->edge[21].tail = 4;
pd->edge[21].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 10;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 10;
pd->comp[1].edge[1] = 11;
pd->comp[1].edge[2] = 12;
pd->comp[1].edge[3] = 13;

pd->comp[2].nedges = 4;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 14;
pd->comp[2].edge[1] = 15;
pd->comp[2].edge[2] = 16;
pd->comp[2].edge[3] = 17;

pd->comp[3].nedges = 4;
pd->comp[3].tag = 'D';

pd->comp[3].edge = calloc(pd->comp[3].nedges,sizeof(pd_idx_t));
assert(pd->comp[3].edge != NULL);

pd->comp[3].edge[0] = 18;
pd->comp[3].edge[1] = 19;
pd->comp[3].edge[2] = 20;
pd->comp[3].edge[3] = 21;


/* Face data */

pd->face[0].nedges = 5;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 15;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 11;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 18;
pd->face[0].or[4] = 0;

pd->face[1].nedges = 5;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 3;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 20;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 8;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 13;
pd->face[1].or[3] = 1;

pd->face[1].edge[4] = 17;
pd->face[1].or[4] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 21;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 3;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 16;
pd->face[2].or[3] = 0;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 17;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 10;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 15;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 6;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 12;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 8;
pd->face[4].or[2] = 1;

pd->face[4].edge[3] = 19;
pd->face[4].or[3] = 0;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 7;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 11;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 14;
pd->face[5].or[2] = 0;

pd->face[5].edge[3] = 13;
pd->face[5].or[3] = 0;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 0;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 4;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 21;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 0;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 18;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 5;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 4;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 9;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 20;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 3;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 5;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 19;
pd->face[9].or[1] = 1;

pd->face[9].edge[2] = 9;
pd->face[9].or[2] = 1;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 2;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 16;
pd->face[10].or[1] = 1;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 7;
pd->face[11].or[0] = 1;

pd->face[11].edge[1] = 12;
pd->face[11].or[1] = 0;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 10;
pd->face[12].or[0] = 0;

pd->face[12].edge[1] = 14;
pd->face[12].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testa() {

  /*                                                                            */
/*     ____13______^_______________    ________________________^_17_          */
/*    /                            \ /                              \         */
/*   /                              /10                              \        */
/*  /              (5)             / \               (3)              \       */
/* /                              14  10                                \      */
/* \                 +-------------+---+----<-----------+-+            /      */
/*  \   _____^____7__|_            v(12)v        ____2___v_|__         /       */
/*   \ /        (11) | \            \ /        / (10)     |  \       /        */
/*    \              |  \            \__15_^_________16_^_|___\ ____/         */
/*   /7\____^____12__|__ \  __^_11__/9       /2           |   3\              */
/*  /                |   6\                 ^             |     \             */
/*  \                v     ^      (0)      1              |     /             */
/*   \        (4)    |      6             /           (2) |    /              */
/*    \             _|______ \ ___<__18_______<__         ^   /               */
/*     \          19 |       5\         /1       \        |  3     (1)        */
/*      8         /  |         ^  (7)  ^          \       | /                 */
/*       \       /   |          \     0            \      |/                  */
/*        \     /    |           5   /             21     |                   */
/*         ^   v     | (9)        \ /                \    |                   */
/*          \ /      |             \        (6)       \ / |                   */
/*           /       |            /0\                  /  |<--tangle          */
/*          /8\      |           /   \                /4\ |                   */
/*         /   \     |          /     ^              /   \|                   */
/*        /     \____|___^_9___/      \_________4___/     |                   */
/*       /           |                                    |\                  */
/*      /            |          (8)                       | \                 */
/*      \            +-------------------->---------------+ /                 */
/*       \                                                 /                  */
/*        \_____________________20_______>________________/                   */

pd_idx_t nedges = 10;
pd_idx_t tangle_faces[10] = {8,1,2,10,3,12,5,11,4,9};
pd_idx_t tangle_edges[10] = {20,3,16,2,10,14,7,12,19,9};
pd_boundary_or_t edge_bdy_or[10] = {in,in,out,out,in,in,out,out,out,in};

pd_idx_t ninterior_cross = 7;
pd_idx_t interior_cross[7] = {0,1,2,4,5,6,9};

pd_idx_t ninterior_edges = 9;
pd_idx_t interior_edge[9] = {0,1,4,5,6,18,11,15,21};


  printf("---------------------------------------\n"
	 "tangle_regenerate test a\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testa_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test a : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test c assembled c code */

pd_code_t *pd_create_tangle_testc_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(4);
assert(pd != NULL);
pd->ncross = 4;
pd->nedges = 8;
pd->ncomps = 1;
pd->nfaces = 6;
sprintf(pd->hash,"%s","BAgGAwMDAwICAQgAAAAAAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 7;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 6;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 5;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 4;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 5;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 7;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 6;
pd->cross[3].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 2;
pd->edge[4].headpos = 1;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 1;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 2;
pd->edge[5].tailpos = 3;

pd->edge[6].head = 3;
pd->edge[6].headpos = 3;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 0;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 3;
pd->edge[7].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 8;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;


/* Face data */

pd->face[0].nedges = 3;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 3;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 6;
pd->face[0].or[2] = 0;

pd->face[1].nedges = 3;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 5;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 2;
pd->face[1].or[2] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 6;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 4;
pd->face[2].or[2] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 4;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 1;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 5;
pd->face[4].or[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 7;
pd->face[5].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testc() {

  /*                                                                            */
/*                                                                            */
/*                ___________       ____________                              */
/*               /           \     /            \                             */
/*              /             \   /              \                            */
/*    (1)      /               \ /                \                           */
/*            |                 \ 0      (0)      |                           */
/*            |               /  \                |                           */
/*            |     (3)      /    \               |                           */
/*            |             /      3              |                           */
/*            |            /        v     T       |                           */
/*            |           /          \    |       0                           */
/*            |           \    (5)    \   v       v                           */
/*            |    +-------\----------/------+    |                           */
/*            ^    |       ^         /       |    |                           */
/*            2    |         7      /        |    |                           */
/*            |    |          \    /         |    |                           */
/*            |    |           \  /          |    |                           */
/*            |    |            \ 3          |    |                           */
/*            |    |             \           |    |                           */
/*            |    |           /  \          |    |                           */
/*            \    +----------/----\---------+   /                            */
/*             \             4      ^           /                             */
/*              \           v  (2)   6         /                              */
/*               \         /          \       /                               */
/*                \_____  / ___<_1___________/                                */
/*                       /2              1                                    */
/*                       \        4)     \                                    */
/*                        5              /                                    */
/*                         \__>_________/                                     */

pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,5,3,2} ;
pd_idx_t tangle_edges[4] = {3,7,4,6} ;
pd_boundary_or_t edge_bdy_or[4] = {in,out,out,in} ;

pd_idx_t ninterior_cross = 1 ;
pd_idx_t interior_cross[1] = {3} ;

pd_idx_t ninterior_edges = 0 ;
pd_idx_t interior_edge[0] = {} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test c\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testc_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test c : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test d assembled c code */

pd_code_t *pd_create_tangle_testd_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(9);
assert(pd != NULL);
pd->ncross = 9;
pd->nedges = 18;
pd->ncomps = 2;
pd->nfaces = 10;
sprintf(pd->hash,"%s","CRIKBwYFAwMCAgICAgIMBgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 5;
pd->cross[0].edge[2] = 11;
pd->cross[0].edge[3] = 4;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 12;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 17;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 12;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 13;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 10;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 9;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 10;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 11;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 17;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 16;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 6;
pd->cross[6].edge[1] = 15;
pd->cross[6].edge[2] = 7;
pd->cross[6].edge[3] = 16;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 15;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 14;
pd->cross[7].sign = 0;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 13;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 14;
pd->cross[8].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 0;
pd->edge[4].headpos = 3;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 0;
pd->edge[5].tailpos = 1;

pd->edge[6].head = 6;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 3;
pd->edge[9].headpos = 3;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 4;
pd->edge[10].headpos = 1;
pd->edge[10].tail = 3;
pd->edge[10].tailpos = 1;

pd->edge[11].head = 0;
pd->edge[11].headpos = 2;
pd->edge[11].tail = 4;
pd->edge[11].tailpos = 3;

pd->edge[12].head = 2;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 1;
pd->edge[12].tailpos = 1;

pd->edge[13].head = 8;
pd->edge[13].headpos = 1;
pd->edge[13].tail = 2;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 7;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 8;
pd->edge[14].tailpos = 3;

pd->edge[15].head = 6;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 7;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 5;
pd->edge[16].headpos = 3;
pd->edge[16].tail = 6;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 1;
pd->edge[17].headpos = 3;
pd->edge[17].tail = 5;
pd->edge[17].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 12;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;

pd->comp[1].nedges = 6;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 12;
pd->comp[1].edge[1] = 13;
pd->comp[1].edge[2] = 14;
pd->comp[1].edge[3] = 15;
pd->comp[1].edge[4] = 16;
pd->comp[1].edge[5] = 17;


/* Face data */

pd->face[0].nedges = 7;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 3;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 11;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 5;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 16;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 7;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 14;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 9;
pd->face[0].or[6] = 1;

pd->face[1].nedges = 6;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 13;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 8;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 15;
pd->face[1].or[3] = 1;

pd->face[1].edge[4] = 6;
pd->face[1].or[4] = 0;

pd->face[1].edge[5] = 17;
pd->face[1].or[5] = 1;

pd->face[2].nedges = 5;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 0;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 4;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 10;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 2;
pd->face[2].or[3] = 0;

pd->face[2].edge[4] = 12;
pd->face[2].or[4] = 0;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 17;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 5;
pd->face[3].or[2] = 0;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 9;
pd->face[4].or[1] = 0;

pd->face[4].edge[2] = 13;
pd->face[4].or[2] = 0;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 1;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 12;
pd->face[5].or[1] = 1;

pd->face[6].nedges = 2;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 10;
pd->face[6].or[1] = 1;

pd->face[7].nedges = 2;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 4;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 11;
pd->face[7].or[1] = 0;

pd->face[8].nedges = 2;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 6;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 16;
pd->face[8].or[1] = 1;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 8;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 14;
pd->face[9].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testd() {

  /*           ____________________________________________________               */
/*          /                                                    \     (6)      */
/*         /                                             ___<4_  /_________     */
/*        /                                             /(7)    /4         \    */
/*       /   +-----------------------------------------/-------/--------+   \   */
/*      /    |                            _____<0_____ \ __<11/         |   |   */
/*     /     |                           /              \0              |   |   */
/*     |     |            (2)           /                5              |   |   */
/*     |     |                         /                  v             |   |   */
/*     |     |                        /         (3)        \            |   |   */
/*     |     |                       /                      \           |   |   */
/*     |     |      ___<12_______________<17______________ 5| _<16_     |   |   */
/*     |     |     /               /1                       6      \    |   |   */
/*     |     |    /               /                         v  (8)  \   |   |   */
/*     |     |   /               1                          |       /   |   |   */
/*     |     |   |      (5)     v          (1)          ___________/    |   |   */
/*     |     |   \             /                       /    |6          |   |   */
/*     |     |    \           /                      15     7           |   |   */
/*     |     |     \         /                       /      v           |   |   */
/*     |     |      \______ / _______13>__           \      |           |   |   */
/*     |     |             /2             \           ^     /           |   |   */
/*     |     |            2                \           \   /            |   |   */
/*     |     |           /        (4)       \           \ /             |   |   */
/*     |     |           |                   \           \ 7       (0)  |   |   */
/*     |     |<-T        v  __________<9_____ \ ___<8___/ \             |   |   */
/*     |     |           | /                   \8          \            |   |   */
/*     |     |           \                      \    (9)    \           |   |   */
/*     |     |          / \3                     \_____14>__/           |   /   */
/*     \    +----------/---\--------------------------------------------+  /    */
/*      \____<10______/     \_______3>____________________________________/     */

pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,7,2,6} ;
pd_idx_t tangle_edges[4] = {11,4,10,3} ;
pd_boundary_or_t edge_bdy_or[4] = {in,in,out,out} ;

pd_idx_t ninterior_cross = 8 ;
pd_idx_t interior_cross[8] = {0,1,2,3,5,6,7,8} ;

pd_idx_t ninterior_edges = 14 ;
pd_idx_t interior_edge[14] = {0,1,2,5,6,7,8,9,12,13,14,15,16,17} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test d\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testd_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test d : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test e assembled c code */

pd_code_t *pd_create_tangle_teste_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(7);
assert(pd != NULL);
pd->ncross = 7;
pd->nedges = 14;
pd->ncomps = 1;
pd->nfaces = 9;
sprintf(pd->hash,"%s","Bw4JBQQDAwMDAwICAQ4AAAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 13;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 7;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 8;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 9;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 8;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 6;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 7;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 11;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 12;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 5;
pd->cross[5].edge[1] = 11;
pd->cross[5].edge[2] = 6;
pd->cross[5].edge[3] = 10;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 9;
pd->cross[6].edge[1] = 12;
pd->cross[6].edge[2] = 10;
pd->cross[6].edge[3] = 13;
pd->cross[6].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 5;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 3;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 5;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 1;
pd->edge[7].headpos = 1;
pd->edge[7].tail = 3;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 2;
pd->edge[8].headpos = 3;
pd->edge[8].tail = 1;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 6;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 2;
pd->edge[9].tailpos = 1;

pd->edge[10].head = 5;
pd->edge[10].headpos = 3;
pd->edge[10].tail = 6;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 4;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 5;
pd->edge[11].tailpos = 1;

pd->edge[12].head = 6;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 4;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 0;
pd->edge[13].headpos = 2;
pd->edge[13].tail = 6;
pd->edge[13].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 14;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;


/* Face data */

pd->face[0].nedges = 5;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 7;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 4;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 12;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 9;
pd->face[0].or[4] = 0;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 3;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 13;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 10;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 6;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 0;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 3;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 7;
pd->face[2].or[2] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 8;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 2;
pd->face[3].or[2] = 1;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 9;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 13;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 4;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 6;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 11;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 5;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 10;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 12;
pd->face[6].or[2] = 0;

pd->face[7].nedges = 2;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 1;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 8;
pd->face[7].or[1] = 0;

pd->face[8].nedges = 2;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 11;
pd->face[8].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_teste() {

  /*     ____________________________________________________________           */
/*    /                                                            \   (5)    */
/*   /                                                              \         */
/*  |                            +--------------------------------+  |        */
/*  |                            |      _____________________     |  |        */
/*  |                            |     /                     \    |  |        */
/*  |                            |    /                       \   |  |        */
/*  |     (0)                 T->|   /                         \  |  |        */
/*  |                            |   |                         |  |  |        */
/*  |                     ___<9_____ | ____________  (7)       |  |  |        */
/*  |                    /       |   |2            \           |  |  |        */
/*  |                   /        |   |              \          |  |  |        */
/*  |                  /         |   2               \         |  |  |        */
/*  |                 /          |   v               |         |  |  |        */
/*  |                /           |   |      (3)      ^         |  |  |        */
/*  |               /      (4)   |   |               8         |  |  |        */
/*  |              /             |   |               |         /  |  |        */
/*  |             /              |   |               /        /   |  |        */
/*  |             |              |   |              /        /    |  |        */
/*  |             |              |   |             /        /     |  |        */
/*  \    ___12>________13>_________________0>___  / __1>___/      |  |        */
/*   \ 4/          6             |    0          /1               |  |        */
/*     /          |              |   |  (2)     /                 |  |        */
/*    /    (6)   10      (1)     |   3         /                  |  |        */
/*   /  \         v              +---|--------/-------------------+  |        */
/*  /    \        |                  v       /                       |        */
/*  |     \_5>________6>____________ | _7>__/                        |        */
/*  \              5                 |3                              |        */
/*   \    (8)     |                  \                               /        */
/*    \______<11__/                   \___4>________________________/         */
pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,4,1,2} ;
pd_idx_t tangle_edges[4] = {9,13,3,7} ;
pd_boundary_or_t edge_bdy_or[4] = {out,in,out,in} ;

pd_idx_t ninterior_cross = 3 ;
pd_idx_t interior_cross[3] = {0,1,2} ;

pd_idx_t ninterior_edges = 4 ;
pd_idx_t interior_edge[4] = {0,1,2,8} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test e\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_teste_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test e : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test f assembled c code */

pd_code_t *pd_create_tangle_testf_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(8);
assert(pd != NULL);
pd->ncross = 8;
pd->nedges = 16;
pd->ncomps = 2;
pd->nfaces = 10;
sprintf(pd->hash,"%s","CBAKBAQEBAMDAwMCAgIKBgAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 6;
pd->cross[0].edge[2] = 9;
pd->cross[0].edge[3] = 7;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 15;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 14;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 11;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 12;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 6;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 5;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 14;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 13;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 4;
pd->cross[5].edge[1] = 12;
pd->cross[5].edge[2] = 5;
pd->cross[5].edge[3] = 13;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 7;
pd->cross[6].edge[1] = 10;
pd->cross[6].edge[2] = 8;
pd->cross[6].edge[3] = 15;
pd->cross[6].sign = 1;

pd->cross[7].edge[0] = 8;
pd->cross[7].edge[1] = 10;
pd->cross[7].edge[2] = 9;
pd->cross[7].edge[3] = 11;
pd->cross[7].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 5;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 3;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 5;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 0;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 3;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 6;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 0;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 7;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 6;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 0;
pd->edge[9].headpos = 2;
pd->edge[9].tail = 7;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 7;
pd->edge[10].headpos = 1;
pd->edge[10].tail = 6;
pd->edge[10].tailpos = 1;

pd->edge[11].head = 2;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 7;
pd->edge[11].tailpos = 3;

pd->edge[12].head = 5;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 2;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 4;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 5;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 1;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 4;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 6;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 1;
pd->edge[15].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 10;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;

pd->comp[1].nedges = 6;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 10;
pd->comp[1].edge[1] = 11;
pd->comp[1].edge[2] = 12;
pd->comp[1].edge[3] = 13;
pd->comp[1].edge[4] = 14;
pd->comp[1].edge[5] = 15;


/* Face data */

pd->face[0].nedges = 4;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 14;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 3;
pd->face[0].or[2] = 0;

pd->face[0].edge[3] = 6;
pd->face[0].or[3] = 1;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 1;

pd->face[1].edge[1] = 12;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 4;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 14;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 15;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 8;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 11;
pd->face[2].or[3] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 11;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 9;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 6;
pd->face[3].or[3] = 0;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 0;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 7;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 15;
pd->face[4].or[2] = 0;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 2;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 5;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 12;
pd->face[5].or[2] = 0;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 13;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 5;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 7;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 9;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 10;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 2;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 4;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 13;
pd->face[8].or[1] = 1;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 8;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testf() {

  /*              _________________________________                             */
/*             /                                 \                            */
/*    (6)     /         _________________________________3>_______            */
/*           /         /                           3              \           */
/*          /   +-----/---------------------------|---------+      \          */
/*         /    |    /                            6         |      |          */
/*        /     |   /             _____9>________ v ___     |      |          */
/*        |     |  /             /                |0   \    |      |          */
/*        |     | /             /                 |     \   |<-T   |          */
/*        |     | |            /        (7)       |      \  |      |          */
/*        |     | |           /                   7       \ |      |          */
/*        |     | |          /                    v       | |      |          */
/*        |     | |          |      __<10__       |       | | (0)  |          */
/*        |     | |     (3)  |     /       \      |       0 |      |          */
/*        |     | |          |    /   (9)   \     |       v |      |          */
/*        |     | |          |    |7        |6    |  (4)  | |      |          */
/*        |     | |          \_________<8___|_____/       | |      |          */
/*        |     | |                         |             / |      |          */
/*        |     | \               |         ^            /  |      |          */
/*        |     |  \              11   (2) 15           /   |      |          */
/*        |     |   \             v         |          /    |      |          */
/*        |(5)  |    \_______<2__ | ___<1_____________/     |      |          */
/*        \     |                 |2         1              |      /          */
/*         \    |                 12  (1)   |               |     /           */
/*          \   +-----------------|---------14--------------+    /            */
/*           \____________<5___________<4__ | __________________/             */
/*                                 5        |4                                */
/*                                |  (8)    |                                 */
/*                                \         /                                 */
/*                                 \_13>___/                                  */
pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,3,5,1} ;
pd_idx_t tangle_edges[4] = {6,2,12,14} ;
pd_boundary_or_t edge_bdy_or[4] = {in,out,out,in} ;

pd_idx_t ninterior_cross = 5 ;
pd_idx_t interior_cross[5] = {0,1,2,6,7} ;

pd_idx_t ninterior_edges = 8 ;
pd_idx_t interior_edge[8] = {0,1,7,8,9,10,11,15} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test f\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testf_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test f : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test g assembled c code */

pd_code_t *pd_create_tangle_testg_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(12);
assert(pd != NULL);
pd->ncross = 12;
pd->nedges = 24;
pd->ncomps = 3;
pd->nfaces = 14;
sprintf(pd->hash,"%s","DBgOBgUFBAQEBAMDAgICAgIDEAQEAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 15;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 5;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 6;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 7;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 6;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 10;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 11;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 4;
pd->cross[4].edge[1] = 12;
pd->cross[4].edge[2] = 5;
pd->cross[4].edge[3] = 11;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 7;
pd->cross[5].edge[1] = 14;
pd->cross[5].edge[2] = 8;
pd->cross[5].edge[3] = 15;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 8;
pd->cross[6].edge[1] = 20;
pd->cross[6].edge[2] = 9;
pd->cross[6].edge[3] = 23;
pd->cross[6].sign = 1;

pd->cross[7].edge[0] = 9;
pd->cross[7].edge[1] = 22;
pd->cross[7].edge[2] = 10;
pd->cross[7].edge[3] = 23;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 12;
pd->cross[8].edge[1] = 17;
pd->cross[8].edge[2] = 13;
pd->cross[8].edge[3] = 16;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 13;
pd->cross[9].edge[1] = 19;
pd->cross[9].edge[2] = 14;
pd->cross[9].edge[3] = 16;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 17;
pd->cross[10].edge[1] = 22;
pd->cross[10].edge[2] = 18;
pd->cross[10].edge[3] = 21;
pd->cross[10].sign = 0;

pd->cross[11].edge[0] = 18;
pd->cross[11].edge[1] = 20;
pd->cross[11].edge[2] = 19;
pd->cross[11].edge[3] = 21;
pd->cross[11].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 4;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 1;
pd->edge[5].headpos = 1;
pd->edge[5].tail = 4;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 2;
pd->edge[6].headpos = 3;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 3;

pd->edge[7].head = 5;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 2;
pd->edge[7].tailpos = 1;

pd->edge[8].head = 6;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 5;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 7;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 6;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 3;
pd->edge[10].headpos = 1;
pd->edge[10].tail = 7;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 4;
pd->edge[11].headpos = 3;
pd->edge[11].tail = 3;
pd->edge[11].tailpos = 3;

pd->edge[12].head = 8;
pd->edge[12].headpos = 0;
pd->edge[12].tail = 4;
pd->edge[12].tailpos = 1;

pd->edge[13].head = 9;
pd->edge[13].headpos = 0;
pd->edge[13].tail = 8;
pd->edge[13].tailpos = 2;

pd->edge[14].head = 5;
pd->edge[14].headpos = 1;
pd->edge[14].tail = 9;
pd->edge[14].tailpos = 2;

pd->edge[15].head = 0;
pd->edge[15].headpos = 2;
pd->edge[15].tail = 5;
pd->edge[15].tailpos = 3;

pd->edge[16].head = 8;
pd->edge[16].headpos = 3;
pd->edge[16].tail = 9;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 10;
pd->edge[17].headpos = 0;
pd->edge[17].tail = 8;
pd->edge[17].tailpos = 1;

pd->edge[18].head = 11;
pd->edge[18].headpos = 0;
pd->edge[18].tail = 10;
pd->edge[18].tailpos = 2;

pd->edge[19].head = 9;
pd->edge[19].headpos = 1;
pd->edge[19].tail = 11;
pd->edge[19].tailpos = 2;

pd->edge[20].head = 11;
pd->edge[20].headpos = 1;
pd->edge[20].tail = 6;
pd->edge[20].tailpos = 1;

pd->edge[21].head = 10;
pd->edge[21].headpos = 3;
pd->edge[21].tail = 11;
pd->edge[21].tailpos = 3;

pd->edge[22].head = 7;
pd->edge[22].headpos = 1;
pd->edge[22].tail = 10;
pd->edge[22].tailpos = 1;

pd->edge[23].head = 6;
pd->edge[23].headpos = 3;
pd->edge[23].tail = 7;
pd->edge[23].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 16;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 16;
pd->comp[1].edge[1] = 17;
pd->comp[1].edge[2] = 18;
pd->comp[1].edge[3] = 19;

pd->comp[2].nedges = 4;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 20;
pd->comp[2].edge[1] = 21;
pd->comp[2].edge[2] = 22;
pd->comp[2].edge[3] = 23;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 1;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 5;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 12;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 16;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 14;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 7;
pd->face[0].or[5] = 0;

pd->face[1].nedges = 5;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 3;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 15;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 8;
pd->face[1].or[2] = 1;

pd->face[1].edge[3] = 23;
pd->face[1].or[3] = 0;

pd->face[1].edge[4] = 10;
pd->face[1].or[4] = 1;

pd->face[2].nedges = 5;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 4;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 10;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 22;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 17;
pd->face[2].or[3] = 0;

pd->face[2].edge[4] = 12;
pd->face[2].or[4] = 0;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 0;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 3;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 11;
pd->face[3].or[2] = 1;

pd->face[3].edge[3] = 5;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 8;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 14;
pd->face[4].or[1] = 0;

pd->face[4].edge[2] = 19;
pd->face[4].or[2] = 0;

pd->face[4].edge[3] = 20;
pd->face[4].or[3] = 0;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 9;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 20;
pd->face[5].or[1] = 1;

pd->face[5].edge[2] = 18;
pd->face[5].or[2] = 0;

pd->face[5].edge[3] = 22;
pd->face[5].or[3] = 1;

pd->face[6].nedges = 4;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 13;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 17;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 21;
pd->face[6].or[2] = 0;

pd->face[6].edge[3] = 19;
pd->face[6].or[3] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 0;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 6;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 2;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 2;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 7;
pd->face[8].or[1] = 1;

pd->face[8].edge[2] = 15;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 1;
pd->face[9].or[0] = 1;

pd->face[9].edge[1] = 6;
pd->face[9].or[1] = 0;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 4;
pd->face[10].or[0] = 1;

pd->face[10].edge[1] = 11;
pd->face[10].or[1] = 0;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 9;
pd->face[11].or[0] = 1;

pd->face[11].edge[1] = 23;
pd->face[11].or[1] = 1;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 13;
pd->face[12].or[0] = 1;

pd->face[12].edge[1] = 16;
pd->face[12].or[1] = 1;

pd->face[13].nedges = 2;
pd->face[13].edge = calloc(pd->face[13].nedges,sizeof(pd_idx_t));
pd->face[13].or = calloc(pd->face[13].nedges,sizeof(pd_or_t));
assert(pd->face[13].edge != NULL);
assert(pd->face[13].or != NULL);

pd->face[13].edge[0] = 18;
pd->face[13].or[0] = 1;

pd->face[13].edge[1] = 21;
pd->face[13].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testg() {

  /*               +------------------------------------------------------+      */
/*               |           ____<16_________                           |      */
/*    (0)        |          /         (12)   \                          |      */
/*       _____12>__________________13>_______ \ ___14>_                 |      */
/*      /        |          8                  \9      \                |      */
/*     /         |         |       (6)         |        \               |      */
/*     |         |         17                 19         \              |      */
/*   _____       |         \  _____<21__ ____  |    (4)   \             |      */
/*  /   4 \      |  (2)     v/               \ /          |             |      */
/* /   |   ^     |        10 \         (13)   \ 11        |             |      */
/* |   |    4    |          / \              / \          |             |      */
/* |   |     \   |         /   \___18>______/   ^         |             |      */
/* 5   \(10) |   |        22                    20        |             |      */
/* v    ^    |   |        |      (5)            |         |             |<-T   */
/* |     \11_______<10___ | _________<9_______________<8_ | __________  |      */
/* |          3  |        \7                     6        |5          \ |      */
/* |         |   |         \        (11)        |         |           | |      */
/* |  (3)    |   |          \                   /         |           | |      */
/* |         ^   |           \___23>___________/          15          | |      */
/* |         3   |                                        v           | |      */
/* |         |   +----------------------------------------/-----------|-+      */
/* |         |                                   (1)     /            |        */
/* \    _<0_ | _________________________________________/             /        */
/*  \  /     2 0                                                     /         */
/*    /  (7) |                   (8)                                /          */
/*   /\_6>_________________7>______________________________________/           */
/*  / 1       2                                                                */
/*  |        |                                                                 */
/*  |   (9)  |                                                                 */
/*  |        /                                                                 */
/*  \___1>__/                                                                  */
pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,2,1,8} ;
pd_idx_t tangle_edges[4] = {12,10,15,7} ;
pd_boundary_or_t edge_bdy_or[4] = {in,out,out,in} ;

pd_idx_t ninterior_cross = 7 ;
pd_idx_t interior_cross[7] = {5,6,7,8,9,10,11} ;

pd_idx_t ninterior_edges = 12 ;
pd_idx_t interior_edge[12] = {8,9,13,14,16,17,18,19,20,21,22,23} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test g\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testg_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test g : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test h assembled c code */

pd_code_t *pd_create_tangle_testh_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(11);
assert(pd != NULL);
pd->ncross = 11;
pd->nedges = 22;
pd->ncomps = 2;
pd->nfaces = 13;
sprintf(pd->hash,"%s","CxYNBQUEBAQEBAMDAgICAgISBAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 4;
pd->cross[0].edge[2] = 17;
pd->cross[0].edge[3] = 5;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 5;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 6;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 15;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 14;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 11;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 12;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 9;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 6;
pd->cross[5].edge[1] = 18;
pd->cross[5].edge[2] = 7;
pd->cross[5].edge[3] = 21;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 7;
pd->cross[6].edge[1] = 20;
pd->cross[6].edge[2] = 8;
pd->cross[6].edge[3] = 21;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 9;
pd->cross[7].edge[1] = 16;
pd->cross[7].edge[2] = 10;
pd->cross[7].edge[3] = 17;
pd->cross[7].sign = 0;

pd->cross[8].edge[0] = 10;
pd->cross[8].edge[1] = 16;
pd->cross[8].edge[2] = 11;
pd->cross[8].edge[3] = 15;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 12;
pd->cross[9].edge[1] = 20;
pd->cross[9].edge[2] = 13;
pd->cross[9].edge[3] = 19;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 13;
pd->cross[10].edge[1] = 18;
pd->cross[10].edge[2] = 14;
pd->cross[10].edge[3] = 19;
pd->cross[10].sign = 0;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 0;
pd->edge[4].headpos = 1;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 1;
pd->edge[5].headpos = 1;
pd->edge[5].tail = 0;
pd->edge[5].tailpos = 3;

pd->edge[6].head = 5;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 3;

pd->edge[7].head = 6;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 5;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 4;
pd->edge[8].headpos = 3;
pd->edge[8].tail = 6;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 7;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 4;
pd->edge[9].tailpos = 1;

pd->edge[10].head = 8;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 7;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 3;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 8;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 9;
pd->edge[12].headpos = 0;
pd->edge[12].tail = 3;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 10;
pd->edge[13].headpos = 0;
pd->edge[13].tail = 9;
pd->edge[13].tailpos = 2;

pd->edge[14].head = 2;
pd->edge[14].headpos = 3;
pd->edge[14].tail = 10;
pd->edge[14].tailpos = 2;

pd->edge[15].head = 8;
pd->edge[15].headpos = 3;
pd->edge[15].tail = 2;
pd->edge[15].tailpos = 1;

pd->edge[16].head = 7;
pd->edge[16].headpos = 1;
pd->edge[16].tail = 8;
pd->edge[16].tailpos = 1;

pd->edge[17].head = 0;
pd->edge[17].headpos = 2;
pd->edge[17].tail = 7;
pd->edge[17].tailpos = 3;

pd->edge[18].head = 10;
pd->edge[18].headpos = 1;
pd->edge[18].tail = 5;
pd->edge[18].tailpos = 1;

pd->edge[19].head = 9;
pd->edge[19].headpos = 3;
pd->edge[19].tail = 10;
pd->edge[19].tailpos = 3;

pd->edge[20].head = 6;
pd->edge[20].headpos = 1;
pd->edge[20].tail = 9;
pd->edge[20].tailpos = 1;

pd->edge[21].head = 5;
pd->edge[21].headpos = 3;
pd->edge[21].tail = 6;
pd->edge[21].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 18;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;

pd->comp[1].nedges = 4;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 18;
pd->comp[1].edge[1] = 19;
pd->comp[1].edge[2] = 20;
pd->comp[1].edge[3] = 21;


/* Face data */

pd->face[0].nedges = 5;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 6;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 21;
pd->face[0].or[2] = 0;

pd->face[0].edge[3] = 8;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 4;
pd->face[0].or[4] = 1;

pd->face[1].nedges = 5;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 5;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 17;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 10;
pd->face[1].or[3] = 1;

pd->face[1].edge[4] = 15;
pd->face[1].or[4] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 14;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 18;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 6;
pd->face[2].or[3] = 0;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 1;

pd->face[3].edge[1] = 12;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 19;
pd->face[3].or[2] = 0;

pd->face[3].edge[3] = 14;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 3;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 0;

pd->face[4].edge[2] = 20;
pd->face[4].or[2] = 0;

pd->face[4].edge[3] = 12;
pd->face[4].or[3] = 0;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 11;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 16;
pd->face[5].or[2] = 1;

pd->face[5].edge[3] = 9;
pd->face[5].or[3] = 0;

pd->face[6].nedges = 4;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 7;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 18;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[6].edge[3] = 20;
pd->face[6].or[3] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 2;
pd->face[7].or[0] = 0;

pd->face[7].edge[1] = 15;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 11;
pd->face[7].or[2] = 1;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 4;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 9;
pd->face[8].or[1] = 1;

pd->face[8].edge[2] = 17;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 0;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 5;
pd->face[9].or[1] = 1;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 7;
pd->face[10].or[0] = 1;

pd->face[10].edge[1] = 21;
pd->face[10].or[1] = 1;

pd->face[11].nedges = 2;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 10;
pd->face[11].or[0] = 0;

pd->face[11].edge[1] = 16;
pd->face[11].or[1] = 0;

pd->face[12].nedges = 2;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 13;
pd->face[12].or[0] = 1;

pd->face[12].edge[1] = 19;
pd->face[12].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testh() {

  /*           +------------------------------+
/*           |                              | <-T                             */
/*        ____<11_________      _______16>_____________________________       */
/*       /   |            \    /            |                          \      */
/*      /   _|__<2____     \  /             |                           \     */
/*     /   / |        \     \ 8             |              (11)          \    */
/*    /    | |         \    /\              |                            |    */
/*   /     | | (3)      \ 15  \             |                            |    */
/*  /      | |     _     /2    \____________|________<10_____            |    */
/*  |      | |    / \  14 \                 |                \           |    */
/*  | (7)  | |  19   \ /   \       _______<5|___              \          |    */
/*  |      | |  v     \10   ^     /         |   \              \         |    */
/*  |      | | / (12)  \     1   /          |    \              \        |    */
/*  |      | ||     /   \( 2) \ /           |     \              \       |    */
/*  |      | | \  13     \     \ 1      (9 )|     |    (1)        \      |    */
/*  |      | |  \ /       ^   | \           |     |                \     |    */
/*  \      | |   / 9      18  |  \          |     |                |     /    */
/*   \____ |_12>/          \  6   \         |     |                |    /     */
/*        3| |     \        \ V    \___<0___|____ | _______<17_________/      */
/*         | |      \  (6)   \|             |     |0                7         */
/*          \|       \        |5            |     |                |          */
/*           \       20       |\      (0)         |                |          */
/*           |\         v     7 \________   |     |                |          */
/*           | \         \    v (10)     \  |     |                |          */
/*           |  \         \    \         |  |     /                |          */
/*           |   \         \_________21>_/  |    /                 |          */
/*       (5) |    \   (4)         6         |   /    (8)           |          */
/*           |     \              \         |  /                   |          */
/*           |      \              8        | /                    |          */
/*           |       \_3>__________ \ ___4>__/                     |          */
/*           +-----------------------\4-----+                      /          */
/*                                    \___________9>______________/           */

pd_idx_t nedges = 10 ;
pd_idx_t tangle_faces[10] = {0,9,1,11,5,7,3,4,5,8} ;
pd_idx_t tangle_edges[10] = {0,5,10,16,11,2,12,3,9,4} ;
pd_boundary_or_t edge_bdy_or[10] = {in,in,in,out,out,out,in,in,out,out} ;

pd_idx_t ninterior_cross = 8 ;
pd_idx_t interior_cross[8] = {1,2,4,5,6,8,9,10} ;

pd_idx_t ninterior_edges = 11 ;
pd_idx_t interior_edge[11] = {1,6,7,8,13,14,15,18,19,20,21} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test h\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testh_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test h : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test i assembled c code */

pd_code_t *pd_create_tangle_testi_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(10);
assert(pd != NULL);
pd->ncross = 10;
pd->nedges = 20;
pd->ncomps = 1;
pd->nfaces = 12;
sprintf(pd->hash,"%s","ChQMCQQEAwMDAwMDAgIBARQAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 10;
pd->cross[0].edge[2] = 19;
pd->cross[0].edge[3] = 11;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 11;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 12;
pd->cross[1].sign = 1;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 13;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 12;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 18;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 17;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 9;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 8;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 4;
pd->cross[5].edge[1] = 15;
pd->cross[5].edge[2] = 5;
pd->cross[5].edge[3] = 16;
pd->cross[5].sign = 1;

pd->cross[6].edge[0] = 5;
pd->cross[6].edge[1] = 6;
pd->cross[6].edge[2] = 6;
pd->cross[6].edge[3] = 7;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 7;
pd->cross[7].edge[1] = 17;
pd->cross[7].edge[2] = 8;
pd->cross[7].edge[3] = 16;
pd->cross[7].sign = 1;

pd->cross[8].edge[0] = 9;
pd->cross[8].edge[1] = 14;
pd->cross[8].edge[2] = 10;
pd->cross[8].edge[3] = 15;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 13;
pd->cross[9].edge[1] = 19;
pd->cross[9].edge[2] = 14;
pd->cross[9].edge[3] = 18;
pd->cross[9].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 5;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 6;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 5;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 6;
pd->edge[6].headpos = 1;
pd->edge[6].tail = 6;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 7;
pd->edge[7].headpos = 0;
pd->edge[7].tail = 6;
pd->edge[7].tailpos = 3;

pd->edge[8].head = 4;
pd->edge[8].headpos = 3;
pd->edge[8].tail = 7;
pd->edge[8].tailpos = 2;

pd->edge[9].head = 8;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 4;
pd->edge[9].tailpos = 1;

pd->edge[10].head = 0;
pd->edge[10].headpos = 1;
pd->edge[10].tail = 8;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 1;
pd->edge[11].headpos = 1;
pd->edge[11].tail = 0;
pd->edge[11].tailpos = 3;

pd->edge[12].head = 2;
pd->edge[12].headpos = 3;
pd->edge[12].tail = 1;
pd->edge[12].tailpos = 3;

pd->edge[13].head = 9;
pd->edge[13].headpos = 0;
pd->edge[13].tail = 2;
pd->edge[13].tailpos = 1;

pd->edge[14].head = 8;
pd->edge[14].headpos = 1;
pd->edge[14].tail = 9;
pd->edge[14].tailpos = 2;

pd->edge[15].head = 5;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 8;
pd->edge[15].tailpos = 3;

pd->edge[16].head = 7;
pd->edge[16].headpos = 3;
pd->edge[16].tail = 5;
pd->edge[16].tailpos = 3;

pd->edge[17].head = 3;
pd->edge[17].headpos = 3;
pd->edge[17].tail = 7;
pd->edge[17].tailpos = 1;

pd->edge[18].head = 9;
pd->edge[18].headpos = 3;
pd->edge[18].tail = 3;
pd->edge[18].tailpos = 1;

pd->edge[19].head = 0;
pd->edge[19].headpos = 2;
pd->edge[19].tail = 9;
pd->edge[19].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 20;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;
pd->comp[0].edge[18] = 18;
pd->comp[0].edge[19] = 19;


/* Face data */

pd->face[0].nedges = 9;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 12;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 2;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 17;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 7;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 6;
pd->face[0].or[5] = 1;

pd->face[0].edge[6] = 5;
pd->face[0].or[6] = 0;

pd->face[0].edge[7] = 15;
pd->face[0].or[7] = 0;

pd->face[0].edge[8] = 10;
pd->face[0].or[8] = 1;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 1;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 11;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 19;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 13;
pd->face[1].or[3] = 0;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 3;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 18;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 14;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 9;
pd->face[2].or[3] = 0;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 13;
pd->face[3].or[1] = 1;

pd->face[3].edge[2] = 18;
pd->face[3].or[2] = 0;

pd->face[4].nedges = 3;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 3;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 0;

pd->face[4].edge[2] = 17;
pd->face[4].or[2] = 1;

pd->face[5].nedges = 3;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 4;
pd->face[5].or[0] = 0;

pd->face[5].edge[1] = 9;
pd->face[5].or[1] = 1;

pd->face[5].edge[2] = 15;
pd->face[5].or[2] = 1;

pd->face[6].nedges = 3;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 4;
pd->face[6].or[0] = 1;

pd->face[6].edge[1] = 16;
pd->face[6].or[1] = 1;

pd->face[6].edge[2] = 8;
pd->face[6].or[2] = 1;

pd->face[7].nedges = 3;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 5;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 1;

pd->face[7].edge[2] = 16;
pd->face[7].or[2] = 0;

pd->face[8].nedges = 3;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 10;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 14;
pd->face[8].or[1] = 0;

pd->face[8].edge[2] = 19;
pd->face[8].or[2] = 1;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 0;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 11;
pd->face[9].or[1] = 1;

pd->face[10].nedges = 2;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 1;
pd->face[10].or[0] = 1;

pd->face[10].edge[1] = 12;
pd->face[10].or[1] = 0;

pd->face[11].nedges = 1;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 6;
pd->face[11].or[0] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testi() {

  /*     ________________________________________<0______                       */
/*    /             + ---------------------------------\--------------------+ */
/*   /    ______________  (0)                          |                    | */
/*   |   /          |   \          _____10>___________________11>________   | */
/*   |   |          |   |         /                    |0                \  | */
/*   |   |          |   |        /        (8)         19   (1)            \ | */
/*   |   |          |   |  _15______________<14_______ | _       __<1___   \| */
/*   |   |          |   | /   / 8                     9|  ^     /       \  || */
/*   |   |          |   | |(5)9  _________<3_   (2)    |   13  /         \ /| */
/*   |   |          |   | v    \4            \         |    \ /  (10)    1| | */
/*   |   |       T->|   | |   / \             \        ^ (3  \2           | | */
/*   |   |          |   | \  4   \      (4)    \       18   / \___<12___/ | | */
/*   |   |          |   |  5/     \             \      |   2              | | */
/*   |   |          |   |  / \     \             \     |  v               | | */
/*   |   |          |   |  |  \     \___<8___     \______/                | | */
/*   |   |          |   |  \   \             \         |3                 | | */
/*   |   |    (11)  |   |   5   \  (6)        \        |                  | | */
/*   |   |          |   |    v   \             \       |                  | | */
/*   |   |          |   |     \   \___16>___________17>/                  / | */
/*   |   |          |   |      \______            7                      /  | */
/*   |   |          |   |             \    (7)  /                       /   | */
/*   |   |          |   |              \       /                       /    | */
/*   |   |          |   \_________________7>__/                       /     | */
/*   |   |          |                    \6                          /      | */
/*   |   \          |                    |                          /       | */
/*   |    \         +--------------------| ----------------------- /--------+ */
/*   |     \                             |                        /           */
/*   \      \                            /                       /    (9)     */
/*    \      \______________________<6__/                       /             */
/*     \_______________________________________________________/              */
pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,11,0,9} ;
pd_idx_t tangle_edges[4] = {6,6,0,0} ;
pd_boundary_or_t edge_bdy_or[4] = {in,out,in,out} ;

pd_idx_t ninterior_cross = 10 ;
pd_idx_t interior_cross[10] = {0,1,2,3,4,5,6,7,8,9} ;

pd_idx_t ninterior_edges = 18 ;
pd_idx_t interior_edge[18] = {1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test i\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testi_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test i : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test j assembled c code */

pd_code_t *pd_create_tangle_testj_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(8);
assert(pd != NULL);
pd->ncross = 8;
pd->nedges = 16;
pd->ncomps = 2;
pd->nfaces = 10;
sprintf(pd->hash,"%s","CBAKBgQEBAQCAgICAgIICAAAAAAAAAA");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 14;
pd->cross[0].edge[2] = 1;
pd->cross[0].edge[3] = 15;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 15;
pd->cross[1].edge[2] = 7;
pd->cross[1].edge[3] = 8;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 12;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 11;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 12;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 13;
pd->cross[3].sign = 0;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 14;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 13;
pd->cross[4].sign = 0;

pd->cross[5].edge[0] = 4;
pd->cross[5].edge[1] = 8;
pd->cross[5].edge[2] = 5;
pd->cross[5].edge[3] = 9;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 5;
pd->cross[6].edge[1] = 10;
pd->cross[6].edge[2] = 6;
pd->cross[6].edge[3] = 9;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 6;
pd->cross[7].edge[1] = 10;
pd->cross[7].edge[2] = 7;
pd->cross[7].edge[3] = 11;
pd->cross[7].sign = 0;


/* Edge data */

pd->edge[0].head = 0;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 1;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 0;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 5;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 6;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 5;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 7;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 6;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 1;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 7;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 5;
pd->edge[8].headpos = 1;
pd->edge[8].tail = 1;
pd->edge[8].tailpos = 3;

pd->edge[9].head = 6;
pd->edge[9].headpos = 3;
pd->edge[9].tail = 5;
pd->edge[9].tailpos = 3;

pd->edge[10].head = 7;
pd->edge[10].headpos = 1;
pd->edge[10].tail = 6;
pd->edge[10].tailpos = 1;

pd->edge[11].head = 2;
pd->edge[11].headpos = 3;
pd->edge[11].tail = 7;
pd->edge[11].tailpos = 3;

pd->edge[12].head = 3;
pd->edge[12].headpos = 1;
pd->edge[12].tail = 2;
pd->edge[12].tailpos = 1;

pd->edge[13].head = 4;
pd->edge[13].headpos = 3;
pd->edge[13].tail = 3;
pd->edge[13].tailpos = 3;

pd->edge[14].head = 0;
pd->edge[14].headpos = 1;
pd->edge[14].tail = 4;
pd->edge[14].tailpos = 1;

pd->edge[15].head = 1;
pd->edge[15].headpos = 1;
pd->edge[15].tail = 0;
pd->edge[15].tailpos = 3;


/* Component Data */

pd->comp[0].nedges = 8;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;

pd->comp[1].nedges = 8;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 8;
pd->comp[1].edge[1] = 9;
pd->comp[1].edge[2] = 10;
pd->comp[1].edge[3] = 11;
pd->comp[1].edge[4] = 12;
pd->comp[1].edge[5] = 13;
pd->comp[1].edge[6] = 14;
pd->comp[1].edge[7] = 15;


/* Face data */

pd->face[0].nedges = 6;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 2;
pd->face[0].or[0] = 1;

pd->face[0].edge[1] = 13;
pd->face[0].or[1] = 1;

pd->face[0].edge[2] = 4;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 9;
pd->face[0].or[3] = 1;

pd->face[0].edge[4] = 6;
pd->face[0].or[4] = 1;

pd->face[0].edge[5] = 11;
pd->face[0].or[5] = 1;

pd->face[1].nedges = 4;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 8;
pd->face[1].or[1] = 1;

pd->face[1].edge[2] = 4;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 14;
pd->face[1].or[3] = 1;

pd->face[2].nedges = 4;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 1;

pd->face[2].edge[1] = 11;
pd->face[2].or[1] = 0;

pd->face[2].edge[2] = 7;
pd->face[2].or[2] = 1;

pd->face[2].edge[3] = 15;
pd->face[2].or[3] = 0;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 1;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 14;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 3;
pd->face[3].or[2] = 0;

pd->face[3].edge[3] = 12;
pd->face[3].or[3] = 0;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 5;
pd->face[4].or[0] = 0;

pd->face[4].edge[1] = 8;
pd->face[4].or[1] = 0;

pd->face[4].edge[2] = 7;
pd->face[4].or[2] = 0;

pd->face[4].edge[3] = 10;
pd->face[4].or[3] = 0;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 0;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 15;
pd->face[5].or[1] = 1;

pd->face[6].nedges = 2;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 2;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 12;
pd->face[6].or[1] = 1;

pd->face[7].nedges = 2;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 3;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 13;
pd->face[7].or[1] = 0;

pd->face[8].nedges = 2;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 5;
pd->face[8].or[0] = 1;

pd->face[8].edge[1] = 9;
pd->face[8].or[1] = 0;

pd->face[9].nedges = 2;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 6;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 10;
pd->face[9].or[1] = 1;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testj() {

  /*            ____________________________________<4______________            */
/*    (1)    /                                                    \           */
/*          /             +--------------------------------------- \ -------+ */
/*         /              |                      (0)                \___    | */
/*        /               |                                             \   | */
/*        |               |                                              \  | */
/*        |            T->|             __6>___                          |  | */
/*        |               |            /  (9)  \                         |  | */
/*        \    __________9>___________/__10>_______11>_                  |  | */
/*         \  /           |   (8)    / 6         7     \    _2>_   _13_  |  | */
/*           / _______5>____________/           |       \  /    \ /    \ |  | */
/*          / 5           |           (4)       |         / (6)  /  (7)  /  | */
/*          \             |                     /        /      /3\     /   | */
/*           \______________________<8____     7        /2\_12_/   \3>_/4\  | */
/*                        |               \   v        /                 |  | */
/*                        |                \ /        /                  |  | */
/*        ________________|                 /1       /                   |  | */
/*       /                |\    _____<0____/  \     /                    |  | */
/*      /                 | \  /              |    /                     |  | */
/*     /                  |  \         (5)    |   /                      |  | */
/*    /                   |   \               |  /                       |  | */
/*   /                    | / 0\___15>________/ /             (3)        |  | */
/*  /                     |/                   /                         |  | */
/*  |                     /           (2)     /                          |  | */
/*  |                    /+------------------/---------------------------|--+ */
/*  |                    |                  /                            |    */
/*  |                    \_______1>________/                             /    */
/*  |                                                                   /     */
/*  \                                                                  /      */
/*   \_________________________________________<14____________________/       */
pd_idx_t nedges = 8 ;
pd_idx_t tangle_faces[8] = {0,8,4,1,3,2,3,1} ;
pd_idx_t tangle_edges[8] = {9,5,8,14,1,1,14,4} ;
pd_boundary_or_t edge_bdy_or[8] = {in,in,out,in,out,in,out,out} ;

pd_idx_t ninterior_cross = 7  ;
pd_idx_t interior_cross[7]  = {0,1,2,3,4,6,7} ;

pd_idx_t ninterior_edges = 10 ;
pd_idx_t interior_edge[10] = {0,2,3,6,7,10,11,12,13,15} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test j\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testj_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test j : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}

/* tangle interior test k assembled c code */

pd_code_t *pd_create_tangle_testk_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(28);
assert(pd != NULL);
pd->ncross = 28;
pd->nedges = 56;
pd->ncomps = 3;
pd->nfaces = 30;
sprintf(pd->hash,"%s","HDgeDwcGBAQEBAQEBAQEBAQDAwMDAwM");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 35;
pd->cross[0].edge[2] = 33;
pd->cross[0].edge[3] = 34;
pd->cross[0].sign = 0;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 36;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 35;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 32;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 33;
pd->cross[2].sign = 0;

pd->cross[3].edge[0] = 2;
pd->cross[3].edge[1] = 55;
pd->cross[3].edge[2] = 3;
pd->cross[3].edge[3] = 48;
pd->cross[3].sign = 1;

pd->cross[4].edge[0] = 3;
pd->cross[4].edge[1] = 51;
pd->cross[4].edge[2] = 4;
pd->cross[4].edge[3] = 50;
pd->cross[4].sign = 1;

pd->cross[5].edge[0] = 4;
pd->cross[5].edge[1] = 8;
pd->cross[5].edge[2] = 5;
pd->cross[5].edge[3] = 7;
pd->cross[5].sign = 0;

pd->cross[6].edge[0] = 5;
pd->cross[6].edge[1] = 44;
pd->cross[6].edge[2] = 6;
pd->cross[6].edge[3] = 45;
pd->cross[6].sign = 0;

pd->cross[7].edge[0] = 6;
pd->cross[7].edge[1] = 46;
pd->cross[7].edge[2] = 7;
pd->cross[7].edge[3] = 45;
pd->cross[7].sign = 0;

pd->cross[8].edge[0] = 8;
pd->cross[8].edge[1] = 12;
pd->cross[8].edge[2] = 9;
pd->cross[8].edge[3] = 11;
pd->cross[8].sign = 0;

pd->cross[9].edge[0] = 9;
pd->cross[9].edge[1] = 42;
pd->cross[9].edge[2] = 10;
pd->cross[9].edge[3] = 43;
pd->cross[9].sign = 0;

pd->cross[10].edge[0] = 10;
pd->cross[10].edge[1] = 44;
pd->cross[10].edge[2] = 11;
pd->cross[10].edge[3] = 43;
pd->cross[10].sign = 0;

pd->cross[11].edge[0] = 12;
pd->cross[11].edge[1] = 51;
pd->cross[11].edge[2] = 13;
pd->cross[11].edge[3] = 52;
pd->cross[11].sign = 1;

pd->cross[12].edge[0] = 13;
pd->cross[12].edge[1] = 55;
pd->cross[12].edge[2] = 14;
pd->cross[12].edge[3] = 54;
pd->cross[12].sign = 1;

pd->cross[13].edge[0] = 14;
pd->cross[13].edge[1] = 32;
pd->cross[13].edge[2] = 15;
pd->cross[13].edge[3] = 31;
pd->cross[13].sign = 0;

pd->cross[14].edge[0] = 15;
pd->cross[14].edge[1] = 38;
pd->cross[14].edge[2] = 16;
pd->cross[14].edge[3] = 39;
pd->cross[14].sign = 0;

pd->cross[15].edge[0] = 16;
pd->cross[15].edge[1] = 29;
pd->cross[15].edge[2] = 17;
pd->cross[15].edge[3] = 30;
pd->cross[15].sign = 1;

pd->cross[16].edge[0] = 17;
pd->cross[16].edge[1] = 24;
pd->cross[16].edge[2] = 18;
pd->cross[16].edge[3] = 25;
pd->cross[16].sign = 1;

pd->cross[17].edge[0] = 18;
pd->cross[17].edge[1] = 21;
pd->cross[17].edge[2] = 19;
pd->cross[17].edge[3] = 22;
pd->cross[17].sign = 1;

pd->cross[18].edge[0] = 19;
pd->cross[18].edge[1] = 23;
pd->cross[18].edge[2] = 20;
pd->cross[18].edge[3] = 22;
pd->cross[18].sign = 0;

pd->cross[19].edge[0] = 20;
pd->cross[19].edge[1] = 23;
pd->cross[19].edge[2] = 21;
pd->cross[19].edge[3] = 24;
pd->cross[19].sign = 1;

pd->cross[20].edge[0] = 25;
pd->cross[20].edge[1] = 29;
pd->cross[20].edge[2] = 26;
pd->cross[20].edge[3] = 28;
pd->cross[20].sign = 0;

pd->cross[21].edge[0] = 26;
pd->cross[21].edge[1] = 38;
pd->cross[21].edge[2] = 27;
pd->cross[21].edge[3] = 37;
pd->cross[21].sign = 0;

pd->cross[22].edge[0] = 27;
pd->cross[22].edge[1] = 36;
pd->cross[22].edge[2] = 28;
pd->cross[22].edge[3] = 37;
pd->cross[22].sign = 0;

pd->cross[23].edge[0] = 30;
pd->cross[23].edge[1] = 40;
pd->cross[23].edge[2] = 31;
pd->cross[23].edge[3] = 39;
pd->cross[23].sign = 0;

pd->cross[24].edge[0] = 34;
pd->cross[24].edge[1] = 48;
pd->cross[24].edge[2] = 47;
pd->cross[24].edge[3] = 49;
pd->cross[24].sign = 1;

pd->cross[25].edge[0] = 40;
pd->cross[25].edge[1] = 53;
pd->cross[25].edge[2] = 41;
pd->cross[25].edge[3] = 54;
pd->cross[25].sign = 1;

pd->cross[26].edge[0] = 41;
pd->cross[26].edge[1] = 53;
pd->cross[26].edge[2] = 42;
pd->cross[26].edge[3] = 52;
pd->cross[26].sign = 1;

pd->cross[27].edge[0] = 46;
pd->cross[27].edge[1] = 49;
pd->cross[27].edge[2] = 47;
pd->cross[27].edge[3] = 50;
pd->cross[27].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 3;
pd->edge[2].headpos = 0;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 4;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 3;
pd->edge[3].tailpos = 2;

pd->edge[4].head = 5;
pd->edge[4].headpos = 0;
pd->edge[4].tail = 4;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 6;
pd->edge[5].headpos = 0;
pd->edge[5].tail = 5;
pd->edge[5].tailpos = 2;

pd->edge[6].head = 7;
pd->edge[6].headpos = 0;
pd->edge[6].tail = 6;
pd->edge[6].tailpos = 2;

pd->edge[7].head = 5;
pd->edge[7].headpos = 3;
pd->edge[7].tail = 7;
pd->edge[7].tailpos = 2;

pd->edge[8].head = 8;
pd->edge[8].headpos = 0;
pd->edge[8].tail = 5;
pd->edge[8].tailpos = 1;

pd->edge[9].head = 9;
pd->edge[9].headpos = 0;
pd->edge[9].tail = 8;
pd->edge[9].tailpos = 2;

pd->edge[10].head = 10;
pd->edge[10].headpos = 0;
pd->edge[10].tail = 9;
pd->edge[10].tailpos = 2;

pd->edge[11].head = 8;
pd->edge[11].headpos = 3;
pd->edge[11].tail = 10;
pd->edge[11].tailpos = 2;

pd->edge[12].head = 11;
pd->edge[12].headpos = 0;
pd->edge[12].tail = 8;
pd->edge[12].tailpos = 1;

pd->edge[13].head = 12;
pd->edge[13].headpos = 0;
pd->edge[13].tail = 11;
pd->edge[13].tailpos = 2;

pd->edge[14].head = 13;
pd->edge[14].headpos = 0;
pd->edge[14].tail = 12;
pd->edge[14].tailpos = 2;

pd->edge[15].head = 14;
pd->edge[15].headpos = 0;
pd->edge[15].tail = 13;
pd->edge[15].tailpos = 2;

pd->edge[16].head = 15;
pd->edge[16].headpos = 0;
pd->edge[16].tail = 14;
pd->edge[16].tailpos = 2;

pd->edge[17].head = 16;
pd->edge[17].headpos = 0;
pd->edge[17].tail = 15;
pd->edge[17].tailpos = 2;

pd->edge[18].head = 17;
pd->edge[18].headpos = 0;
pd->edge[18].tail = 16;
pd->edge[18].tailpos = 2;

pd->edge[19].head = 18;
pd->edge[19].headpos = 0;
pd->edge[19].tail = 17;
pd->edge[19].tailpos = 2;

pd->edge[20].head = 19;
pd->edge[20].headpos = 0;
pd->edge[20].tail = 18;
pd->edge[20].tailpos = 2;

pd->edge[21].head = 17;
pd->edge[21].headpos = 1;
pd->edge[21].tail = 19;
pd->edge[21].tailpos = 2;

pd->edge[22].head = 18;
pd->edge[22].headpos = 3;
pd->edge[22].tail = 17;
pd->edge[22].tailpos = 3;

pd->edge[23].head = 19;
pd->edge[23].headpos = 1;
pd->edge[23].tail = 18;
pd->edge[23].tailpos = 1;

pd->edge[24].head = 16;
pd->edge[24].headpos = 1;
pd->edge[24].tail = 19;
pd->edge[24].tailpos = 3;

pd->edge[25].head = 20;
pd->edge[25].headpos = 0;
pd->edge[25].tail = 16;
pd->edge[25].tailpos = 3;

pd->edge[26].head = 21;
pd->edge[26].headpos = 0;
pd->edge[26].tail = 20;
pd->edge[26].tailpos = 2;

pd->edge[27].head = 22;
pd->edge[27].headpos = 0;
pd->edge[27].tail = 21;
pd->edge[27].tailpos = 2;

pd->edge[28].head = 20;
pd->edge[28].headpos = 3;
pd->edge[28].tail = 22;
pd->edge[28].tailpos = 2;

pd->edge[29].head = 15;
pd->edge[29].headpos = 1;
pd->edge[29].tail = 20;
pd->edge[29].tailpos = 1;

pd->edge[30].head = 23;
pd->edge[30].headpos = 0;
pd->edge[30].tail = 15;
pd->edge[30].tailpos = 3;

pd->edge[31].head = 13;
pd->edge[31].headpos = 3;
pd->edge[31].tail = 23;
pd->edge[31].tailpos = 2;

pd->edge[32].head = 2;
pd->edge[32].headpos = 1;
pd->edge[32].tail = 13;
pd->edge[32].tailpos = 1;

pd->edge[33].head = 0;
pd->edge[33].headpos = 2;
pd->edge[33].tail = 2;
pd->edge[33].tailpos = 3;

pd->edge[34].head = 0;
pd->edge[34].headpos = 3;
pd->edge[34].tail = 24;
pd->edge[34].tailpos = 0;

pd->edge[35].head = 1;
pd->edge[35].headpos = 3;
pd->edge[35].tail = 0;
pd->edge[35].tailpos = 1;

pd->edge[36].head = 22;
pd->edge[36].headpos = 1;
pd->edge[36].tail = 1;
pd->edge[36].tailpos = 1;

pd->edge[37].head = 21;
pd->edge[37].headpos = 3;
pd->edge[37].tail = 22;
pd->edge[37].tailpos = 3;

pd->edge[38].head = 14;
pd->edge[38].headpos = 1;
pd->edge[38].tail = 21;
pd->edge[38].tailpos = 1;

pd->edge[39].head = 23;
pd->edge[39].headpos = 3;
pd->edge[39].tail = 14;
pd->edge[39].tailpos = 3;

pd->edge[40].head = 25;
pd->edge[40].headpos = 0;
pd->edge[40].tail = 23;
pd->edge[40].tailpos = 1;

pd->edge[41].head = 26;
pd->edge[41].headpos = 0;
pd->edge[41].tail = 25;
pd->edge[41].tailpos = 2;

pd->edge[42].head = 9;
pd->edge[42].headpos = 1;
pd->edge[42].tail = 26;
pd->edge[42].tailpos = 2;

pd->edge[43].head = 10;
pd->edge[43].headpos = 3;
pd->edge[43].tail = 9;
pd->edge[43].tailpos = 3;

pd->edge[44].head = 6;
pd->edge[44].headpos = 1;
pd->edge[44].tail = 10;
pd->edge[44].tailpos = 1;

pd->edge[45].head = 7;
pd->edge[45].headpos = 3;
pd->edge[45].tail = 6;
pd->edge[45].tailpos = 3;

pd->edge[46].head = 27;
pd->edge[46].headpos = 0;
pd->edge[46].tail = 7;
pd->edge[46].tailpos = 1;

pd->edge[47].head = 24;
pd->edge[47].headpos = 2;
pd->edge[47].tail = 27;
pd->edge[47].tailpos = 2;

pd->edge[48].head = 24;
pd->edge[48].headpos = 1;
pd->edge[48].tail = 3;
pd->edge[48].tailpos = 3;

pd->edge[49].head = 27;
pd->edge[49].headpos = 1;
pd->edge[49].tail = 24;
pd->edge[49].tailpos = 3;

pd->edge[50].head = 4;
pd->edge[50].headpos = 3;
pd->edge[50].tail = 27;
pd->edge[50].tailpos = 3;

pd->edge[51].head = 11;
pd->edge[51].headpos = 1;
pd->edge[51].tail = 4;
pd->edge[51].tailpos = 1;

pd->edge[52].head = 26;
pd->edge[52].headpos = 3;
pd->edge[52].tail = 11;
pd->edge[52].tailpos = 3;

pd->edge[53].head = 25;
pd->edge[53].headpos = 1;
pd->edge[53].tail = 26;
pd->edge[53].tailpos = 1;

pd->edge[54].head = 12;
pd->edge[54].headpos = 3;
pd->edge[54].tail = 25;
pd->edge[54].tailpos = 3;

pd->edge[55].head = 3;
pd->edge[55].headpos = 1;
pd->edge[55].tail = 12;
pd->edge[55].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 34;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;
pd->comp[0].edge[8] = 8;
pd->comp[0].edge[9] = 9;
pd->comp[0].edge[10] = 10;
pd->comp[0].edge[11] = 11;
pd->comp[0].edge[12] = 12;
pd->comp[0].edge[13] = 13;
pd->comp[0].edge[14] = 14;
pd->comp[0].edge[15] = 15;
pd->comp[0].edge[16] = 16;
pd->comp[0].edge[17] = 17;
pd->comp[0].edge[18] = 18;
pd->comp[0].edge[19] = 19;
pd->comp[0].edge[20] = 20;
pd->comp[0].edge[21] = 21;
pd->comp[0].edge[22] = 22;
pd->comp[0].edge[23] = 23;
pd->comp[0].edge[24] = 24;
pd->comp[0].edge[25] = 25;
pd->comp[0].edge[26] = 26;
pd->comp[0].edge[27] = 27;
pd->comp[0].edge[28] = 28;
pd->comp[0].edge[29] = 29;
pd->comp[0].edge[30] = 30;
pd->comp[0].edge[31] = 31;
pd->comp[0].edge[32] = 32;
pd->comp[0].edge[33] = 33;

pd->comp[1].nedges = 14;
pd->comp[1].tag = 'B';

pd->comp[1].edge = calloc(pd->comp[1].nedges,sizeof(pd_idx_t));
assert(pd->comp[1].edge != NULL);

pd->comp[1].edge[0] = 34;
pd->comp[1].edge[1] = 35;
pd->comp[1].edge[2] = 36;
pd->comp[1].edge[3] = 37;
pd->comp[1].edge[4] = 38;
pd->comp[1].edge[5] = 39;
pd->comp[1].edge[6] = 40;
pd->comp[1].edge[7] = 41;
pd->comp[1].edge[8] = 42;
pd->comp[1].edge[9] = 43;
pd->comp[1].edge[10] = 44;
pd->comp[1].edge[11] = 45;
pd->comp[1].edge[12] = 46;
pd->comp[1].edge[13] = 47;

pd->comp[2].nedges = 8;
pd->comp[2].tag = 'C';

pd->comp[2].edge = calloc(pd->comp[2].nedges,sizeof(pd_idx_t));
assert(pd->comp[2].edge != NULL);

pd->comp[2].edge[0] = 48;
pd->comp[2].edge[1] = 49;
pd->comp[2].edge[2] = 50;
pd->comp[2].edge[3] = 51;
pd->comp[2].edge[4] = 52;
pd->comp[2].edge[5] = 53;
pd->comp[2].edge[6] = 54;
pd->comp[2].edge[7] = 55;


/* Face data */

pd->face[0].nedges = 15;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].or = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].or != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].or[0] = 0;

pd->face[0].edge[1] = 34;
pd->face[0].or[1] = 0;

pd->face[0].edge[2] = 49;
pd->face[0].or[2] = 1;

pd->face[0].edge[3] = 46;
pd->face[0].or[3] = 0;

pd->face[0].edge[4] = 6;
pd->face[0].or[4] = 0;

pd->face[0].edge[5] = 44;
pd->face[0].or[5] = 0;

pd->face[0].edge[6] = 10;
pd->face[0].or[6] = 0;

pd->face[0].edge[7] = 42;
pd->face[0].or[7] = 0;

pd->face[0].edge[8] = 53;
pd->face[0].or[8] = 1;

pd->face[0].edge[9] = 40;
pd->face[0].or[9] = 0;

pd->face[0].edge[10] = 30;
pd->face[0].or[10] = 0;

pd->face[0].edge[11] = 17;
pd->face[0].or[11] = 1;

pd->face[0].edge[12] = 25;
pd->face[0].or[12] = 1;

pd->face[0].edge[13] = 28;
pd->face[0].or[13] = 0;

pd->face[0].edge[14] = 36;
pd->face[0].or[14] = 0;

pd->face[1].nedges = 7;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].or = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].or != NULL);

pd->face[1].edge[0] = 17;
pd->face[1].or[0] = 0;

pd->face[1].edge[1] = 29;
pd->face[1].or[1] = 0;

pd->face[1].edge[2] = 25;
pd->face[1].or[2] = 0;

pd->face[1].edge[3] = 18;
pd->face[1].or[3] = 1;

pd->face[1].edge[4] = 22;
pd->face[1].or[4] = 1;

pd->face[1].edge[5] = 20;
pd->face[1].or[5] = 1;

pd->face[1].edge[6] = 24;
pd->face[1].or[6] = 1;

pd->face[2].nedges = 6;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].or = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].or != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].or[0] = 0;

pd->face[2].edge[1] = 36;
pd->face[2].or[1] = 1;

pd->face[2].edge[2] = 27;
pd->face[2].or[2] = 0;

pd->face[2].edge[3] = 38;
pd->face[2].or[3] = 1;

pd->face[2].edge[4] = 15;
pd->face[2].or[4] = 0;

pd->face[2].edge[5] = 32;
pd->face[2].or[5] = 1;

pd->face[3].nedges = 4;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].or = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].or != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].or[0] = 0;

pd->face[3].edge[1] = 32;
pd->face[3].or[1] = 0;

pd->face[3].edge[2] = 14;
pd->face[3].or[2] = 0;

pd->face[3].edge[3] = 55;
pd->face[3].or[3] = 1;

pd->face[4].nedges = 4;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].or = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].or != NULL);

pd->face[4].edge[0] = 2;
pd->face[4].or[0] = 1;

pd->face[4].edge[1] = 48;
pd->face[4].or[1] = 1;

pd->face[4].edge[2] = 34;
pd->face[4].or[2] = 1;

pd->face[4].edge[3] = 33;
pd->face[4].or[3] = 0;

pd->face[5].nedges = 4;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].or = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].or != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].or[0] = 1;

pd->face[5].edge[1] = 50;
pd->face[5].or[1] = 0;

pd->face[5].edge[2] = 47;
pd->face[5].or[2] = 1;

pd->face[5].edge[3] = 48;
pd->face[5].or[3] = 0;

pd->face[6].nedges = 4;
pd->face[6].edge = calloc(pd->face[6].nedges,sizeof(pd_idx_t));
pd->face[6].or = calloc(pd->face[6].nedges,sizeof(pd_or_t));
assert(pd->face[6].edge != NULL);
assert(pd->face[6].or != NULL);

pd->face[6].edge[0] = 3;
pd->face[6].or[0] = 0;

pd->face[6].edge[1] = 55;
pd->face[6].or[1] = 0;

pd->face[6].edge[2] = 13;
pd->face[6].or[2] = 0;

pd->face[6].edge[3] = 51;
pd->face[6].or[3] = 0;

pd->face[7].nedges = 4;
pd->face[7].edge = calloc(pd->face[7].nedges,sizeof(pd_idx_t));
pd->face[7].or = calloc(pd->face[7].nedges,sizeof(pd_or_t));
assert(pd->face[7].edge != NULL);
assert(pd->face[7].or != NULL);

pd->face[7].edge[0] = 4;
pd->face[7].or[0] = 1;

pd->face[7].edge[1] = 7;
pd->face[7].or[1] = 0;

pd->face[7].edge[2] = 46;
pd->face[7].or[2] = 1;

pd->face[7].edge[3] = 50;
pd->face[7].or[3] = 1;

pd->face[8].nedges = 4;
pd->face[8].edge = calloc(pd->face[8].nedges,sizeof(pd_idx_t));
pd->face[8].or = calloc(pd->face[8].nedges,sizeof(pd_or_t));
assert(pd->face[8].edge != NULL);
assert(pd->face[8].or != NULL);

pd->face[8].edge[0] = 4;
pd->face[8].or[0] = 0;

pd->face[8].edge[1] = 51;
pd->face[8].or[1] = 1;

pd->face[8].edge[2] = 12;
pd->face[8].or[2] = 0;

pd->face[8].edge[3] = 8;
pd->face[8].or[3] = 0;

pd->face[9].nedges = 4;
pd->face[9].edge = calloc(pd->face[9].nedges,sizeof(pd_idx_t));
pd->face[9].or = calloc(pd->face[9].nedges,sizeof(pd_or_t));
assert(pd->face[9].edge != NULL);
assert(pd->face[9].or != NULL);

pd->face[9].edge[0] = 5;
pd->face[9].or[0] = 0;

pd->face[9].edge[1] = 8;
pd->face[9].or[1] = 1;

pd->face[9].edge[2] = 11;
pd->face[9].or[2] = 0;

pd->face[9].edge[3] = 44;
pd->face[9].or[3] = 1;

pd->face[10].nedges = 4;
pd->face[10].edge = calloc(pd->face[10].nedges,sizeof(pd_idx_t));
pd->face[10].or = calloc(pd->face[10].nedges,sizeof(pd_or_t));
assert(pd->face[10].edge != NULL);
assert(pd->face[10].or != NULL);

pd->face[10].edge[0] = 9;
pd->face[10].or[0] = 0;

pd->face[10].edge[1] = 12;
pd->face[10].or[1] = 1;

pd->face[10].edge[2] = 52;
pd->face[10].or[2] = 1;

pd->face[10].edge[3] = 42;
pd->face[10].or[3] = 1;

pd->face[11].nedges = 4;
pd->face[11].edge = calloc(pd->face[11].nedges,sizeof(pd_idx_t));
pd->face[11].or = calloc(pd->face[11].nedges,sizeof(pd_or_t));
assert(pd->face[11].edge != NULL);
assert(pd->face[11].or != NULL);

pd->face[11].edge[0] = 13;
pd->face[11].or[0] = 1;

pd->face[11].edge[1] = 54;
pd->face[11].or[1] = 0;

pd->face[11].edge[2] = 41;
pd->face[11].or[2] = 1;

pd->face[11].edge[3] = 52;
pd->face[11].or[3] = 0;

pd->face[12].nedges = 4;
pd->face[12].edge = calloc(pd->face[12].nedges,sizeof(pd_idx_t));
pd->face[12].or = calloc(pd->face[12].nedges,sizeof(pd_or_t));
assert(pd->face[12].edge != NULL);
assert(pd->face[12].or != NULL);

pd->face[12].edge[0] = 14;
pd->face[12].or[0] = 1;

pd->face[12].edge[1] = 31;
pd->face[12].or[1] = 0;

pd->face[12].edge[2] = 40;
pd->face[12].or[2] = 1;

pd->face[12].edge[3] = 54;
pd->face[12].or[3] = 1;

pd->face[13].nedges = 4;
pd->face[13].edge = calloc(pd->face[13].nedges,sizeof(pd_idx_t));
pd->face[13].or = calloc(pd->face[13].nedges,sizeof(pd_or_t));
assert(pd->face[13].edge != NULL);
assert(pd->face[13].or != NULL);

pd->face[13].edge[0] = 16;
pd->face[13].or[0] = 0;

pd->face[13].edge[1] = 38;
pd->face[13].or[1] = 0;

pd->face[13].edge[2] = 26;
pd->face[13].or[2] = 0;

pd->face[13].edge[3] = 29;
pd->face[13].or[3] = 1;

pd->face[14].nedges = 3;
pd->face[14].edge = calloc(pd->face[14].nedges,sizeof(pd_idx_t));
pd->face[14].or = calloc(pd->face[14].nedges,sizeof(pd_or_t));
assert(pd->face[14].edge != NULL);
assert(pd->face[14].or != NULL);

pd->face[14].edge[0] = 1;
pd->face[14].or[0] = 1;

pd->face[14].edge[1] = 33;
pd->face[14].or[1] = 1;

pd->face[14].edge[2] = 35;
pd->face[14].or[2] = 1;

pd->face[15].nedges = 3;
pd->face[15].edge = calloc(pd->face[15].nedges,sizeof(pd_idx_t));
pd->face[15].or = calloc(pd->face[15].nedges,sizeof(pd_or_t));
assert(pd->face[15].edge != NULL);
assert(pd->face[15].or != NULL);

pd->face[15].edge[0] = 5;
pd->face[15].or[0] = 1;

pd->face[15].edge[1] = 45;
pd->face[15].or[1] = 1;

pd->face[15].edge[2] = 7;
pd->face[15].or[2] = 1;

pd->face[16].nedges = 3;
pd->face[16].edge = calloc(pd->face[16].nedges,sizeof(pd_idx_t));
pd->face[16].or = calloc(pd->face[16].nedges,sizeof(pd_or_t));
assert(pd->face[16].edge != NULL);
assert(pd->face[16].or != NULL);

pd->face[16].edge[0] = 9;
pd->face[16].or[0] = 1;

pd->face[16].edge[1] = 43;
pd->face[16].or[1] = 1;

pd->face[16].edge[2] = 11;
pd->face[16].or[2] = 1;

pd->face[17].nedges = 3;
pd->face[17].edge = calloc(pd->face[17].nedges,sizeof(pd_idx_t));
pd->face[17].or = calloc(pd->face[17].nedges,sizeof(pd_or_t));
assert(pd->face[17].edge != NULL);
assert(pd->face[17].or != NULL);

pd->face[17].edge[0] = 15;
pd->face[17].or[0] = 1;

pd->face[17].edge[1] = 39;
pd->face[17].or[1] = 1;

pd->face[17].edge[2] = 31;
pd->face[17].or[2] = 1;

pd->face[18].nedges = 3;
pd->face[18].edge = calloc(pd->face[18].nedges,sizeof(pd_idx_t));
pd->face[18].or = calloc(pd->face[18].nedges,sizeof(pd_or_t));
assert(pd->face[18].edge != NULL);
assert(pd->face[18].or != NULL);

pd->face[18].edge[0] = 16;
pd->face[18].or[0] = 1;

pd->face[18].edge[1] = 30;
pd->face[18].or[1] = 1;

pd->face[18].edge[2] = 39;
pd->face[18].or[2] = 0;

pd->face[19].nedges = 3;
pd->face[19].edge = calloc(pd->face[19].nedges,sizeof(pd_idx_t));
pd->face[19].or = calloc(pd->face[19].nedges,sizeof(pd_or_t));
assert(pd->face[19].edge != NULL);
assert(pd->face[19].or != NULL);

pd->face[19].edge[0] = 18;
pd->face[19].or[0] = 0;

pd->face[19].edge[1] = 24;
pd->face[19].or[1] = 0;

pd->face[19].edge[2] = 21;
pd->face[19].or[2] = 1;

pd->face[20].nedges = 3;
pd->face[20].edge = calloc(pd->face[20].nedges,sizeof(pd_idx_t));
pd->face[20].or = calloc(pd->face[20].nedges,sizeof(pd_or_t));
assert(pd->face[20].edge != NULL);
assert(pd->face[20].or != NULL);

pd->face[20].edge[0] = 19;
pd->face[20].or[0] = 0;

pd->face[20].edge[1] = 21;
pd->face[20].or[1] = 0;

pd->face[20].edge[2] = 23;
pd->face[20].or[2] = 0;

pd->face[21].nedges = 3;
pd->face[21].edge = calloc(pd->face[21].nedges,sizeof(pd_idx_t));
pd->face[21].or = calloc(pd->face[21].nedges,sizeof(pd_or_t));
assert(pd->face[21].edge != NULL);
assert(pd->face[21].or != NULL);

pd->face[21].edge[0] = 26;
pd->face[21].or[0] = 1;

pd->face[21].edge[1] = 37;
pd->face[21].or[1] = 0;

pd->face[21].edge[2] = 28;
pd->face[21].or[2] = 1;

pd->face[22].nedges = 2;
pd->face[22].edge = calloc(pd->face[22].nedges,sizeof(pd_idx_t));
pd->face[22].or = calloc(pd->face[22].nedges,sizeof(pd_or_t));
assert(pd->face[22].edge != NULL);
assert(pd->face[22].or != NULL);

pd->face[22].edge[0] = 0;
pd->face[22].or[0] = 1;

pd->face[22].edge[1] = 35;
pd->face[22].or[1] = 0;

pd->face[23].nedges = 2;
pd->face[23].edge = calloc(pd->face[23].nedges,sizeof(pd_idx_t));
pd->face[23].or = calloc(pd->face[23].nedges,sizeof(pd_or_t));
assert(pd->face[23].edge != NULL);
assert(pd->face[23].or != NULL);

pd->face[23].edge[0] = 6;
pd->face[23].or[0] = 1;

pd->face[23].edge[1] = 45;
pd->face[23].or[1] = 0;

pd->face[24].nedges = 2;
pd->face[24].edge = calloc(pd->face[24].nedges,sizeof(pd_idx_t));
pd->face[24].or = calloc(pd->face[24].nedges,sizeof(pd_or_t));
assert(pd->face[24].edge != NULL);
assert(pd->face[24].or != NULL);

pd->face[24].edge[0] = 10;
pd->face[24].or[0] = 1;

pd->face[24].edge[1] = 43;
pd->face[24].or[1] = 0;

pd->face[25].nedges = 2;
pd->face[25].edge = calloc(pd->face[25].nedges,sizeof(pd_idx_t));
pd->face[25].or = calloc(pd->face[25].nedges,sizeof(pd_or_t));
assert(pd->face[25].edge != NULL);
assert(pd->face[25].or != NULL);

pd->face[25].edge[0] = 19;
pd->face[25].or[0] = 1;

pd->face[25].edge[1] = 22;
pd->face[25].or[1] = 0;

pd->face[26].nedges = 2;
pd->face[26].edge = calloc(pd->face[26].nedges,sizeof(pd_idx_t));
pd->face[26].or = calloc(pd->face[26].nedges,sizeof(pd_or_t));
assert(pd->face[26].edge != NULL);
assert(pd->face[26].or != NULL);

pd->face[26].edge[0] = 20;
pd->face[26].or[0] = 0;

pd->face[26].edge[1] = 23;
pd->face[26].or[1] = 1;

pd->face[27].nedges = 2;
pd->face[27].edge = calloc(pd->face[27].nedges,sizeof(pd_idx_t));
pd->face[27].or = calloc(pd->face[27].nedges,sizeof(pd_or_t));
assert(pd->face[27].edge != NULL);
assert(pd->face[27].or != NULL);

pd->face[27].edge[0] = 27;
pd->face[27].or[0] = 1;

pd->face[27].edge[1] = 37;
pd->face[27].or[1] = 1;

pd->face[28].nedges = 2;
pd->face[28].edge = calloc(pd->face[28].nedges,sizeof(pd_idx_t));
pd->face[28].or = calloc(pd->face[28].nedges,sizeof(pd_or_t));
assert(pd->face[28].edge != NULL);
assert(pd->face[28].or != NULL);

pd->face[28].edge[0] = 41;
pd->face[28].or[0] = 0;

pd->face[28].edge[1] = 53;
pd->face[28].or[1] = 0;

pd->face[29].nedges = 2;
pd->face[29].edge = calloc(pd->face[29].nedges,sizeof(pd_idx_t));
pd->face[29].or = calloc(pd->face[29].nedges,sizeof(pd_or_t));
assert(pd->face[29].edge != NULL);
assert(pd->face[29].or != NULL);

pd->face[29].edge[0] = 47;
pd->face[29].or[0] = 0;

pd->face[29].edge[1] = 49;
pd->face[29].or[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testk() {

  /*  ____________<6_______                                     ______________   */
/* /                     \                                   /      (24)    \  */
/* |        +------------|-----------------------------------|---------+    |  */
/* |        |   ___<45____________________________<44_______ | ______  |    |  */
/* |    T ->|  /         |6                                  |10     \ |    |  */
/* |        |  |         |                                   |       | |    |  */
/* |        |  |         |                                   11(16)  ^ |    |  */
/* |  (23)  |  |         ^                                   v      43 |    |  */
/* |        |  |   (15)  5                  (9)              |       | |    |  */
/* \_______________7>___ | ___________8>________________________9>__ | _10>_/  */
/*          |  |7        |5                                   8      |9|       */
/* (0)      | 46  (7)    4                 (8)              12 (10) 42 |       */
/*          |  v         |                                   v       | |       */
/*     _______ | _50>_____________51>_______________________ | _52>____53____  */
/*    /     |  |27       |4                                  |11     |26     \ */
/*    |(29) | 47   (5)   ^                 (6)              13 (11)  ^ |(28) | */
/*    |     |  |         3                                   |      41 |     | */
/*    \___<49_____<48____|___________________<55_______________<54__ | ______/ */
/*          |  |24       ^3                                  |12     |25       */
/*          | 34  (4)    2                  (3)             14 (12) 40 |       */
/*          |  v         |                                   v       | |       */
/*   _____<0__ | __<33______________<32_____________________ | _<31__________  */
/*  /       |  |0        |2                                  |13     |23     \ */
/*  |       +--|---------^----------------------------------15-------|-+     | */
/*  |          |   (14)  1     (1)     ____<27____           v (17)  |       | */
/*  |          |         |            /    (27)   \          |       |       | */
/*  |          \__35>___ | _36>_________37>______ | ____38>______39>_/       | */
/*  |   (22)             |1          |22          |21        |14             | */
/*  |                    |           |            ^         16               | */
/*  \____________________/          28           26          v               | */
/*                                   |            |          |               | */
/*                                   |            |          |       (18)    | */
/*                                   |            |   (13)   |               | */
/*                                   |      (21)  |          |               / */
/*                                   |            |          |              /  */
/*                                   \            |          |             /   */
/*                                    \           |          |            /    */
/*                                     \          |          |           /     */
/*                                      \         /          |          /      */
/*                                       \______ /___29>_____|__30>____/       */
/*                                              /20          |15               */
/*                                             /             |                 */
/*                     _______________________/             17                 */
/*                    /        ___20>__________              v                 */
/*                   /        /                \             |                 */
/*                  /        /       (26)       \            |                 */
/*                 /         |                  |            |                 */
/*                /          |  ____23>________ | _24_       /                 */
/*               /           \ /                |19   \     /                  */
/*              /             /                21      \   /                   */
/*             /             / \        (20)    v (19)  \ /                    */
/*            /             / 18\               |        \                     */
/*           /             /      \______<19________<18_/ \16                  */
/*          /              |                    |17        \                   */
/*          |              |      (25)          /          |                   */
/*          |     (2)      \                   /           |                   */
/*          |               \________<22______/            |                   */
/*          \                                              |                   */
/*           \__________________________________<25________/                   */
/*                                                                             */   
pd_idx_t nedges = 14 ;            
pd_idx_t tangle_faces[14] = {0,29,0,22,14,1,17,18,0,28,0,24,0,23} ;
pd_idx_t tangle_edges[14] = {49,49,0,35,1,15,39,23,53,53,10,10,6,6} ;
pd_boundary_or_t edge_bdy_or[14] = {in,out,out,out,in,out,in,in,in,out,out,in,out,in} ;

pd_idx_t ninterior_cross = 18  ;
pd_idx_t interior_cross[18]  = {0,2,3,4,5,6,7,8,9,10,11,12,13,23,24,25,26,27} ;

pd_idx_t ninterior_edges = 29  ;
pd_idx_t interior_edge[29] = {2,3,4,5,7,8,9,11,12,13,14,31,32,33,34,40,41,42,43,44,45,46,47,48,50,51,52,54,55} ;


  printf("---------------------------------------\n"
	 "tangle_regenerate test k\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testk_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test k : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}


int main() {

  printf("test_tangle_regenerate_auto (%s)\n",PACKAGE_STRING);
  printf("--------------------------------------------------------\n"
	 "Unit tests for pd_tangle_regenerate. \n"
	 "========================================================\n");

  if (tangle_testa()&&tangle_testc()&&tangle_testd()&&tangle_teste()&&tangle_testf()&&tangle_testg()&&tangle_testh()&&tangle_testi()&&tangle_testj()&&tangle_testk()) {

    printf("=======================================================\n");
    printf("test_tangle_regenerate_auto:  PASS.\n");
    exit(0);

  } else {

    printf("=====================================================\n");
    printf("test_tangle_regenerate_auto:  FAIL.\n");
    exit(1);

  }

  return 0;

}
