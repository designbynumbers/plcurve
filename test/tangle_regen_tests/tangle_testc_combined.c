/* tangle interior test c assembled c code */

pd_code_t *pd_create_tangle_testc_0() { 

/* This procedure is machine generated by pd_write_c */
/* and probably shouldn't be hand-edited. */

pd_code_t *pd;
pd = pd_code_new(4);
assert(pd != NULL);
pd->ncross = 4;
pd->nedges = 8;
pd->ncomps = 1;
pd->nfaces = 6;
sprintf(pd->hash,"%s","unset");

/* Crossing data. */

pd->cross[0].edge[0] = 0;
pd->cross[0].edge[1] = 2;
pd->cross[0].edge[2] = 7;
pd->cross[0].edge[3] = 3;
pd->cross[0].sign = 1;

pd->cross[1].edge[0] = 0;
pd->cross[1].edge[1] = 6;
pd->cross[1].edge[2] = 1;
pd->cross[1].edge[3] = 5;
pd->cross[1].sign = 0;

pd->cross[2].edge[0] = 1;
pd->cross[2].edge[1] = 4;
pd->cross[2].edge[2] = 2;
pd->cross[2].edge[3] = 5;
pd->cross[2].sign = 1;

pd->cross[3].edge[0] = 3;
pd->cross[3].edge[1] = 7;
pd->cross[3].edge[2] = 4;
pd->cross[3].edge[3] = 6;
pd->cross[3].sign = 1;


/* Edge data */

pd->edge[0].head = 1;
pd->edge[0].headpos = 0;
pd->edge[0].tail = 0;
pd->edge[0].tailpos = 0;

pd->edge[1].head = 2;
pd->edge[1].headpos = 0;
pd->edge[1].tail = 1;
pd->edge[1].tailpos = 2;

pd->edge[2].head = 0;
pd->edge[2].headpos = 1;
pd->edge[2].tail = 2;
pd->edge[2].tailpos = 2;

pd->edge[3].head = 3;
pd->edge[3].headpos = 0;
pd->edge[3].tail = 0;
pd->edge[3].tailpos = 3;

pd->edge[4].head = 2;
pd->edge[4].headpos = 1;
pd->edge[4].tail = 3;
pd->edge[4].tailpos = 2;

pd->edge[5].head = 1;
pd->edge[5].headpos = 3;
pd->edge[5].tail = 2;
pd->edge[5].tailpos = 3;

pd->edge[6].head = 3;
pd->edge[6].headpos = 3;
pd->edge[6].tail = 1;
pd->edge[6].tailpos = 1;

pd->edge[7].head = 0;
pd->edge[7].headpos = 2;
pd->edge[7].tail = 3;
pd->edge[7].tailpos = 1;


/* Component Data */

pd->comp[0].nedges = 8;
pd->comp[0].tag = 'A';

pd->comp[0].edge = calloc(pd->comp[0].nedges,sizeof(pd_idx_t));
assert(pd->comp[0].edge != NULL);

pd->comp[0].edge[0] = 0;
pd->comp[0].edge[1] = 1;
pd->comp[0].edge[2] = 2;
pd->comp[0].edge[3] = 3;
pd->comp[0].edge[4] = 4;
pd->comp[0].edge[5] = 5;
pd->comp[0].edge[6] = 6;
pd->comp[0].edge[7] = 7;


/* Face data */

pd->face[0].nedges = 3;
pd->face[0].edge = calloc(pd->face[0].nedges,sizeof(pd_idx_t));
pd->face[0].orient = calloc(pd->face[0].nedges,sizeof(pd_or_t));
assert(pd->face[0].edge != NULL);
assert(pd->face[0].orient != NULL);

pd->face[0].edge[0] = 0;
pd->face[0].orient[0] = 0;

pd->face[0].edge[1] = 3;
pd->face[0].orient[1] = 1;

pd->face[0].edge[2] = 6;
pd->face[0].orient[2] = 0;

pd->face[1].nedges = 3;
pd->face[1].edge = calloc(pd->face[1].nedges,sizeof(pd_idx_t));
pd->face[1].orient = calloc(pd->face[1].nedges,sizeof(pd_or_t));
assert(pd->face[1].edge != NULL);
assert(pd->face[1].orient != NULL);

pd->face[1].edge[0] = 0;
pd->face[1].orient[0] = 1;

pd->face[1].edge[1] = 5;
pd->face[1].orient[1] = 0;

pd->face[1].edge[2] = 2;
pd->face[1].orient[2] = 1;

pd->face[2].nedges = 3;
pd->face[2].edge = calloc(pd->face[2].nedges,sizeof(pd_idx_t));
pd->face[2].orient = calloc(pd->face[2].nedges,sizeof(pd_or_t));
assert(pd->face[2].edge != NULL);
assert(pd->face[2].orient != NULL);

pd->face[2].edge[0] = 1;
pd->face[2].orient[0] = 0;

pd->face[2].edge[1] = 6;
pd->face[2].orient[1] = 1;

pd->face[2].edge[2] = 4;
pd->face[2].orient[2] = 1;

pd->face[3].nedges = 3;
pd->face[3].edge = calloc(pd->face[3].nedges,sizeof(pd_idx_t));
pd->face[3].orient = calloc(pd->face[3].nedges,sizeof(pd_or_t));
assert(pd->face[3].edge != NULL);
assert(pd->face[3].orient != NULL);

pd->face[3].edge[0] = 2;
pd->face[3].orient[0] = 0;

pd->face[3].edge[1] = 4;
pd->face[3].orient[1] = 0;

pd->face[3].edge[2] = 7;
pd->face[3].orient[2] = 1;

pd->face[4].nedges = 2;
pd->face[4].edge = calloc(pd->face[4].nedges,sizeof(pd_idx_t));
pd->face[4].orient = calloc(pd->face[4].nedges,sizeof(pd_or_t));
assert(pd->face[4].edge != NULL);
assert(pd->face[4].orient != NULL);

pd->face[4].edge[0] = 1;
pd->face[4].orient[0] = 1;

pd->face[4].edge[1] = 5;
pd->face[4].orient[1] = 1;

pd->face[5].nedges = 2;
pd->face[5].edge = calloc(pd->face[5].nedges,sizeof(pd_idx_t));
pd->face[5].orient = calloc(pd->face[5].nedges,sizeof(pd_or_t));
assert(pd->face[5].edge != NULL);
assert(pd->face[5].orient != NULL);

pd->face[5].edge[0] = 3;
pd->face[5].orient[0] = 0;

pd->face[5].edge[1] = 7;
pd->face[5].orient[1] = 0;


/* End of data. */

assert(pd_ok(pd));
return pd;

}


bool tangle_testc() {

  /*                                                                            */
/*                                                                            */
/*                ___________       ____________                              */
/*               /           \     /            \                             */
/*              /             \   /              \                            */
/*    (1)      /               \ /                \                           */
/*            |                 \ 0      (0)      |                           */
/*            |               /  \                |                           */
/*            |     (3)      /    \               |                           */
/*            |             /      3              |                           */
/*            |            /        v     T       |                           */
/*            |           /          \    |       0                           */
/*            |           \    (5)    \   v       v                           */
/*            |    +-------\----------/------+    |                           */
/*            ^    |       ^         /       |    |                           */
/*            2    |         7      /        |    |                           */
/*            |    |          \    /         |    |                           */
/*            |    |           \  /          |    |                           */
/*            |    |            \ 3          |    |                           */
/*            |    |             \           |    |                           */
/*            |    |           /  \          |    |                           */
/*            \    +----------/----\---------+   /                            */
/*             \             4      ^           /                             */
/*              \           v  (2)   6         /                              */
/*               \         /          \       /                               */
/*                \_____  / ___<_1___________/                                */
/*                       /2              1                                    */
/*                       \        4)     \                                    */
/*                        5              /                                    */
/*                         \__>_________/                                     */

pd_idx_t nedges = 4 ;
pd_idx_t tangle_faces[4] = {0,5,3,2} ;
pd_idx_t tangle_edges[4] = {3,7,4,6} ;
pd_boundary_or_t edge_bdy_or[4] = {in,out,out,in} ;

pd_idx_t ninterior_cross = 1 ;
pd_idx_t interior_cross[1] = {3};

pd_idx_t ninterior_edges = 0;
pd_idx_t interior_edge[1] = {PD_UNSET_IDX} ;

pd_idx_t nstrands = 2;
pd_tangle_strand_t strand_data[2] = {{0,2,2,0},
				     {3,1,2,0}};


  printf("---------------------------------------\n"
	 "tangle_regenerate test c\n"
	 "---------------------------------------\n");

  printf("creating pd...");
  pd_code_t *pd = pd_create_tangle_testc_0();
  if (!pd_ok(pd)) {

    printf("fail (doesn't pass pd_ok)\n");
    return false;

  }
  
  printf("pass (passes pd_ok)\n");

  printf("creating basic tangle information...");
  pd_tangle_t *t = pd_tangle_new(nedges);

  pd_idx_t i;
  for(i=0;i<t->nedges;i++) {
  
    t->edge[i] = tangle_edges[i];
    t->face[i] = tangle_faces[i];

  }

  printf("done (tangle has %d edges)\n",nedges);

  printf("running pd_regenerate_tangle...");
  pd_regenerate_tangle(pd,t);

  if (!pd_tangle_ok(pd,t)) {

    printf("fail (doesn't pass pd_tangle_ok)\n");
    return false;
    
  }

  printf("pass (didn't crash, passes pd_tangle_ok)\n");

  printf("testing edge boundary orientations...");

  for(i=0;i<t->nedges;i++) {

    if (t->edge_bdy_or[i] != edge_bdy_or[i]) {

      pd_idx_t j;

      printf("fail (list of boundary orientations for tangles doesn't match expected at pos %d)\n",i);

      printf("found:   ");

      for(j=0;j<t->nedges;j++) {

        if (t->edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      printf("expected:");

      for(j=0;j<t->nedges;j++) {

        if (edge_bdy_or[j] == in) { printf("  in "); }
        else { printf(" out "); }

      }

      printf("\n");

      return false;

    }

  }

  printf("pass (edge boundary orientations match expected)\n");

  printf("checking interior crossings...");
  qsort(interior_cross,(size_t)(ninterior_cross),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_cross != ninterior_cross) {

    printf("fail (# interior crossings found (%d) != # expected (%d))\n",
    t->ninterior_cross,ninterior_cross);
    return false;

  }

  for(i=0;i<t->ninterior_cross;i++) {

     if (t->interior_cross[i] != interior_cross[i]) {

        pd_idx_t j;

        printf("fail (list of interior crossings doesn't match expected at pos %d)\n",i);

        printf("found:   ");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",t->interior_cross[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_cross;j++) {

          printf(" %4d ",interior_cross[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior crossings match)\n");


  printf("checking interior edges...");
  qsort(interior_edge,(size_t)(ninterior_edges),sizeof(pd_idx_t),pd_idx_cmp);

  if (t->ninterior_edges != ninterior_edges) {

    printf("fail (# interior edges found (%d) != # expected (%d))\n",
    t->ninterior_edges,ninterior_edges);
    return false;

  }

  for(i=0;i<t->ninterior_edges;i++) {

     if (t->interior_edge[i] != interior_edge[i]) {

        pd_idx_t j;

        printf("fail (list of interior edges doesn't match expected at pos %d)\n",i);

        printf("found:    ");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",t->interior_edge[j]);

        }

        printf("\n");

        printf("expected:");

        for(j=0;j<t->ninterior_edges;j++) {

          printf(" %4d ",interior_edge[j]);

        }

        printf("\n");

        return false;

    }

  }

  printf("pass (interior edges match)\n");

  printf("testing strand data (%d) strands...\n",nstrands);

  for(i=0;i<nstrands;i++) {

     printf("\tstrand %d...",i);

     if(strand_data[i].start_edge != t->strand[i].start_edge) {

        printf("FAIL. (start_edge %d != expected start_edge %d)\n",
               strand_data[i].start_edge,t->strand[i].start_edge);
        return false;

     }

     if(strand_data[i].end_edge != t->strand[i].end_edge) {

        printf("FAIL. (end_edge %d != expected end_edge %d)\n",
               strand_data[i].end_edge,t->strand[i].end_edge);
        return false;

     }

     if(strand_data[i].nedges != t->strand[i].nedges) {

        printf("FAIL. (nedges %d != expected nedges %d)\n",
               strand_data[i].nedges,t->strand[i].nedges);
        return false;

     }

      if(strand_data[i].comp != t->strand[i].comp) {

        printf("FAIL. (comp %d != expected comp %d)\n",
               strand_data[i].comp,t->strand[i].comp);
        return false;

     }

     printf("pass\n");

  }

  printf("testing strand data (%d) strands...pass\n",nstrands);
  
  printf("housecleaning...");
  
  pd_code_free(&pd);
  pd_tangle_free(&t);

  printf("done\n");

  printf("---------------------------------------\n"
         "tangle test c : PASS\n"
	     "---------------------------------------\n");
  
  return true;

}